<!doctype html><html lang="zh-CN"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="generator" content="VuePress 2.0.0-rc.26" /><meta name="theme" content="VuePress Theme Plume 1.0.0-rc.180" /><script id="check-mac-os">document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><script id="check-dark-mode">;(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;const isDark = um === 'dark' || (um !== 'light' && sm);document.documentElement.dataset.theme = isDark ? 'dark' : 'light';})();</script><link rel="icon" type="image/svg+xml" href="/assests/jade_light.svg"><title>调试理论 | JinBlog</title><meta name="description" content="走在未知的道路上, 不许停也不能回头"><link rel="preload" href="/JinBlog/assets/style-Dud8xOD9.css" as="style"><link rel="stylesheet" href="/JinBlog/assets/style-Dud8xOD9.css"><link rel="modulepreload" href="/JinBlog/assets/app-AuyBpmKP.js"><link rel="modulepreload" href="/JinBlog/assets/index.html-BBt5SV0l.js"></head><body><div id="app"><!--[--><!--[--><div class="theme-plume vp-layout" vp-container data-v-6fcf39b7><!--[--><!--[--><!--]--><!--[--><span tabindex="-1" data-v-a1e390b2></span><a href="#VPContent" class="vp-skip-link visually-hidden" data-v-a1e390b2> Skip to content </a><!--]--><!----><header class="vp-nav" data-v-6fcf39b7 data-v-04ce2e5b><div class="vp-navbar" vp-navbar data-v-04ce2e5b data-v-43d9cf9e><div class="wrapper" data-v-43d9cf9e><div class="container" data-v-43d9cf9e><div class="title" data-v-43d9cf9e><div class="vp-navbar-title" data-v-43d9cf9e data-v-6c4c1c9c><a class="vp-link link no-icon title" href="/JinBlog/" data-v-6c4c1c9c><!--[--><!--[--><!--]--><!--[--><!--[--><!--[--><img class="vp-image dark logo" style="" src="/JinBlog/assests/jade_light.svg" alt data-v-264f5058><!--]--><!--[--><img class="vp-image light logo" style="" src="/JinBlog/assests/jade_light.svg" alt data-v-264f5058><!--]--><!--]--><!--]--><span data-v-6c4c1c9c>JinBlog</span><!--[--><!--]--><!--]--></a></div></div><div class="content" data-v-43d9cf9e><div class="content-body" data-v-43d9cf9e><!--[--><!--]--><div class="vp-navbar-search search" data-v-43d9cf9e><div class="search-wrapper" data-v-47ff7b1a><!----><div id="local-search" data-v-47ff7b1a><button type="button" class="mini-search mini-search-button" aria-label="搜索文档" data-v-47ff7b1a><span class="mini-search-button-container"><span class="mini-search-search-icon vpi-mini-search" aria-label="search icon"></span><span class="mini-search-button-placeholder">搜索文档</span></span><span class="mini-search-button-keys"><kbd class="mini-search-button-key"></kbd><kbd class="mini-search-button-key">K</kbd></span></button></div></div></div><!--[--><!--]--><nav aria-labelledby="main-nav-aria-label" class="vp-navbar-menu menu" data-v-43d9cf9e data-v-098c5d7d><span id="main-nav-aria-label" class="visually-hidden" data-v-098c5d7d>Main Navigation</span><!--[--><!--[--><a class="vp-link link navbar-menu-link" href="/JinBlog/" tabindex="0" data-v-098c5d7d data-v-6cfe1038><!--[--><!----><span data-v-6cfe1038>首页</span><!----><!--]--></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/JinBlog/blog/posts/" tabindex="0" data-v-098c5d7d data-v-6cfe1038><!--[--><!----><span data-v-6cfe1038>博客</span><!----><!--]--></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/JinBlog/fzu_cs_course/" tabindex="0" data-v-098c5d7d data-v-6cfe1038><!--[--><!----><span data-v-6cfe1038>FZU CS课程</span><!----><!--]--></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/JinBlog/dl_llm/vllm-anatomy/" tabindex="0" data-v-098c5d7d data-v-6cfe1038><!--[--><!----><span data-v-6cfe1038>DL-LLM</span><!----><!--]--></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/JinBlog/csdiy/10-414/" tabindex="0" data-v-098c5d7d data-v-6cfe1038><!--[--><!----><span data-v-6cfe1038>CSDIY公开课</span><!----><!--]--></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/JinBlog/tools/linux-install/" tabindex="0" data-v-098c5d7d data-v-6cfe1038><!--[--><!----><span data-v-6cfe1038>工具分享</span><!----><!--]--></a><!--]--><!--]--></nav><!--[--><!--]--><!----><div class="vp-navbar-appearance appearance" data-v-43d9cf9e data-v-e59180ad><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-e59180ad data-v-3baa2a62 data-v-4dd2fff8><span class="check" data-v-4dd2fff8><span class="icon" data-v-4dd2fff8><!--[--><span class="vpi-sun sun" data-v-3baa2a62></span><span class="vpi-moon moon" data-v-3baa2a62></span><!--]--></span></span></button></div><div class="vp-social-links vp-navbar-social-links social-links" data-v-43d9cf9e data-v-967cd3fa data-v-4bcc4c24><!--[--><a class="vp-social-link no-icon" href="https://github.com/yJader/JinBlog" aria-label="github" target="_blank" rel="noopener" data-v-4bcc4c24 data-v-961e560d><span class="vpi-social-github" /></a><!--]--></div><div class="vp-flyout vp-navbar-extra extra" data-v-43d9cf9e data-v-3d0b13b6 data-v-d83556c7><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-d83556c7><span class="vpi-more-horizontal icon" data-v-d83556c7></span></button><div class="menu" data-v-d83556c7><div class="vp-menu" data-v-d83556c7 data-v-77899dba><!----><!--[--><!--[--><!----><div class="group" data-v-3d0b13b6><div class="item appearance" data-v-3d0b13b6><p class="label" data-v-3d0b13b6>外观</p><div class="appearance-action" data-v-3d0b13b6><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-3d0b13b6 data-v-3baa2a62 data-v-4dd2fff8><span class="check" data-v-4dd2fff8><span class="icon" data-v-4dd2fff8><!--[--><span class="vpi-sun sun" data-v-3baa2a62></span><span class="vpi-moon moon" data-v-3baa2a62></span><!--]--></span></span></button></div></div></div><div class="group" data-v-3d0b13b6><div class="item social-links" data-v-3d0b13b6><div class="vp-social-links social-links-list" data-v-3d0b13b6 data-v-4bcc4c24><!--[--><a class="vp-social-link no-icon" href="https://github.com/yJader/JinBlog" aria-label="github" target="_blank" rel="noopener" data-v-4bcc4c24 data-v-961e560d><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="vp-navbar-hamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="nav-screen" data-v-43d9cf9e data-v-6c75f11b><span class="container" data-v-6c75f11b><span class="top" data-v-6c75f11b></span><span class="middle" data-v-6c75f11b></span><span class="bottom" data-v-6c75f11b></span></span></button></div></div></div></div><div class="divider" data-v-43d9cf9e><div class="divider-line" data-v-43d9cf9e></div></div></div><!----></header><!----><!----><!--[--><div id="VPContent" vp-content class="vp-content" data-v-6fcf39b7 data-v-743d3d68><div class="vp-doc-container is-posts" data-v-743d3d68 data-v-50e98be9><!--[--><!--]--><div class="container" data-v-50e98be9><!----><div class="content" data-v-50e98be9><div class="content-container" data-v-50e98be9><!--[--><!--]--><main class="main" data-v-50e98be9><!----><!--[--><!--]--><!--[--><div class="vp-doc-title" data-v-1b67cc8d><!--[--><!--]--><h1 class="page-title" data-v-1b67cc8d><!----> 调试理论 <!----></h1><!--[--><!--]--></div><div class="vp-doc-meta" data-v-1b67cc8d><!--[--><!--]--><p class="reading-time" data-v-1b67cc8d><span class="vpi-books icon" data-v-1b67cc8d></span><span data-v-1b67cc8d>约 2198 字</span><span data-v-1b67cc8d>大约 7 分钟</span></p><!----><!--[--><!--]--><p class="create-time" data-v-1b67cc8d><span class="vpi-clock icon" data-v-1b67cc8d></span><span data-v-1b67cc8d>2024-06-30</span></p></div><!--]--><!--[--><!--]--><div class="_blog_qswio9dx_ external-link-icon-enabled vp-doc plume-content" vp-content data-v-50e98be9><!--[--><!--]--><div data-v-50e98be9><blockquote><p>来自蒋炎岩老师的OS2024Spring课程</p><ul><li><a href="https://jyywiki.cn/OS/2024/lect8.md" target="_blank" rel="noopener noreferrer">Yanyan&#39;s Wiki (jyywiki.cn)</a></li><li><a href="https://www.bilibili.com/video/BV16p421U7fk" target="_blank" rel="noopener noreferrer">08-调试理论与实践 (Fault, Error, Failure；调试一切)【南京大学2024操作系统】</a></li></ul></blockquote><h2 id="调试心态" tabindex="-1"><a class="header-anchor" href="#调试心态"><span>调试心态</span></a></h2><h3 id="公理-1-机器永远是对的" tabindex="-1"><a class="header-anchor" href="#公理-1-机器永远是对的"><span>公理 1：<strong>机器永远是对的</strong></span></a></h3><ul><li>CPU: “无情的、执行指令的机器”</li><li>Crash, Wrong Answer, 虚拟机神秘重启 <ul><li>99.9999% 是自己的问题</li><li>有亿点点概率是编译器错了 (但你可以知道)</li><li>有亿点点点点概率是处理器错了 (你也可以知道)</li></ul></li></ul><h3 id="公理-2-未测代码永远是错的" tabindex="-1"><a class="header-anchor" href="#公理-2-未测代码永远是错的"><span>公理 2：<strong>未测代码永远是错的</strong></span></a></h3><ul><li>未反复测试过的代码都是错的 <ul><li>快速地测试→测试框架&amp;&amp;测试用例</li></ul></li><li>你以为最不可能出 bug 的地方，往往 bug 就在那躺着</li></ul><h2 id="why-is-there-bug" tabindex="-1"><a class="header-anchor" href="#why-is-there-bug"><span>Why is there bug?</span></a></h2><blockquote><p>每个鏖战的夜晚都会发出的怒吼QAQ</p></blockquote><h3 id="软件-的两层含义" tabindex="-1"><a class="header-anchor" href="#软件-的两层含义"><span>“软件” 的两层含义</span></a></h3><ul><li>人类需求在信息世界的<strong>投影</strong><ul><li>理解错需求 → bug</li></ul></li><li>计算过程的精确 (数学) 描述 <ul><li>实现错误 → bug</li></ul></li></ul><h3 id="调试为什么困难" tabindex="-1"><a class="header-anchor" href="#调试为什么困难"><span>调试为什么困难？</span></a></h3><ul><li>Bug 的触发经历了漫长的过程</li><li>可观测的现象未必能直接对应到 root cause 上</li></ul><h3 id="fault-error-和-failure" tabindex="-1"><a class="header-anchor" href="#fault-error-和-failure"><span>Fault, Error, 和 Failure</span></a></h3><p>需求 → 设计 → 代码 (<em>[起因]</em> <strong>Fault/bug</strong>) → 执行 (<em>[中间因素]</em> <strong>Error</strong>) → 失败 (<em>[结果]</em> <strong>Failure</strong>)</p><ul><li><p>我们只能观测到 failure (可观测的结果中的错误)</p></li><li><p>我们可以检查状态的正确性 (但非常费时)</p></li><li><p>无法预知 bug 在哪里 (每一行 “看起来” 都挺对的)</p><ul><li><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> j </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> j </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        ...    </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>人总是 “默认” (不默认，浪费的时间就太多了)</p></li></ul><h2 id="调试理论" tabindex="-1"><a class="header-anchor" href="#调试理论"><span>调试理论</span></a></h2><blockquote><p><mark>调试理论</mark>：如果我们能判定任意程序状态的正确性，那么给定一个 failure，我们可以通过二分查找定位到第一个 error 的状态，此时的代码就是 fault (bug)。</p></blockquote><h3 id="推论" tabindex="-1"><a class="header-anchor" href="#推论"><span>推论</span></a></h3><ul><li>为什么我们喜欢 “单步调试”？ <ul><li>从一个假定正确的状态出发</li><li>每个语句的行为有限，容易判定是否是 error</li></ul></li><li>为什么调试理论看起来很没用？ <ul><li><strong>“判定状态正确” 非常困难</strong></li><li>(是否在调试 DP 题/图论算法时陷入时间黑洞？)</li></ul></li></ul><h3 id="调试-观察状态机执行-trace-的某个侧面" tabindex="-1"><a class="header-anchor" href="#调试-观察状态机执行-trace-的某个侧面"><span>调试 = 观察状态机执行 (trace) 的某个侧面</span></a></h3><blockquote><p>程序的运行就是一个状态机</p></blockquote><ul><li>缩小错误状态 (error) 可能产生的位置</li><li>提出假设，作出验证</li></ul><h3 id="观察状态机执行的两个基本工具" tabindex="-1"><a class="header-anchor" href="#观察状态机执行的两个基本工具"><span>观察状态机执行的两个基本工具</span></a></h3><ul><li>printf → 自定义 log 的 trace <ul><li>灵活可控、能快速定位问题大概位置、适用于大型软件 <ul><li>用多个log将程序的运行状态分隔, 进行bug定位</li></ul></li><li>无法精确定位、大量的 logs 管理起来比较麻烦</li></ul></li><li>gdb → 指令/语句级 trace <ul><li>精确、指令级定位、任意查看程序内部状态</li><li>耗费大量时间</li></ul></li></ul><h3 id="如何理解调试理论" tabindex="-1"><a class="header-anchor" href="#如何理解调试理论"><span>如何理解调试理论</span></a></h3><p>调试理论给了大家在遇到 “任何问题” 时候 self-check 的列表：</p><blockquote><p>记住: <strong>机器永远是对的</strong></p></blockquote><ol><li>是怎样的程序 (状态机) 在运行？</li><li>我们遇到了怎样的 failure？</li><li>我们能从状态机的运行中从易到难得到什么信息？</li><li>如何二分检查这些信息和 error 之间的关联？</li></ol><h2 id="调试一切" tabindex="-1"><a class="header-anchor" href="#调试一切"><span>调试一切</span></a></h2><h3 id="computer-world-一切皆可调试" tabindex="-1"><a class="header-anchor" href="#computer-world-一切皆可调试"><span>Computer world: 一切皆可调试</span></a></h3><h4 id="计算机随时随地都在拒绝你" tabindex="-1"><a class="header-anchor" href="#计算机随时随地都在拒绝你"><span>计算机随时随地都在拒绝你</span></a></h4><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">bash:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> curl:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> command</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> not</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> found</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">fatal</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> error:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">sys/cdefs.h</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> No</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> such</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> file</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> or</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> directory</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> #include &lt;sys/cdefs.h&gt; </span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">/usr/bin/ld:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> cannot</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> find</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -lgcc:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> No</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> such</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> file</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> or</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> directory</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">make[2]:</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> ***</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> No</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> such</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> file</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> or</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> directory.</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">  Stop.</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> Makefile:31:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> recipe</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> for</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> target</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">run</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> failed</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>万能方法：假设你遇到的问题是别人也遇到的</strong></p><ul><li>但如果这是一个全新的问题？</li></ul><h4 id="程序-计算机系统-状态机" tabindex="-1"><a class="header-anchor" href="#程序-计算机系统-状态机"><span>程序 = 计算机系统 = 状态机</span></a></h4><blockquote><p>机器永远是对的</p></blockquote><p>UNIX 世界里你做任何事情都是在**<mark>编程</mark>**</p><ul><li>“用编程语言把脑中所想传达给电脑” <ul><li>命令行的命令就是编程 → 一个简短的shell脚本</li><li>最开始使用图形化界面运行/debug也是编程 → 可以发现vscode只是代替你执行了一些命令行语句</li></ul></li><li>刚才的问题都可以看成是程序/输入/配置有 bug</li></ul><h4 id="调试理论可以用于解决任何-问题" tabindex="-1"><a class="header-anchor" href="#调试理论可以用于解决任何-问题"><span>调试理论可以用于解决任何 “问题”</span></a></h4><ul><li>curl: command not found</li><li><code>&#39;sys/cdefs.h&#39;</code>: No such file or directory</li><li>Makefile:31: recipe for target &#39;run&#39; failed</li></ul><h3 id="使用调试理论" tabindex="-1"><a class="header-anchor" href="#使用调试理论"><span>使用调试理论</span></a></h3><h4 id="fault-程序-输入-配置错-→-error-→-failure-可观测" tabindex="-1"><a class="header-anchor" href="#fault-程序-输入-配置错-→-error-→-failure-可观测"><span>Fault (程序/输入/配置错) → Error → Failure (可观测)</span></a></h4><ul><li>大部分 Error 和 Failure 都比较接近 <ul><li>出错时，使用 perror 打印日志</li></ul></li></ul><h4 id="找不到问题-的原因" tabindex="-1"><a class="header-anchor" href="#找不到问题-的原因"><span>“找不到问题” 的原因</span></a></h4><ul><li><strong>出错原因报告不准确</strong><ul><li>也可能是没看懂</li><li>对于大型项目(如Spring)更是这样, 对于一种Failure有多种可能的Fault, 当STFW时, 很可能会搜到多种不相干的Fault😞</li><li>这个时候把这些报错信息丢给LLM不失为一个好选择😄</li></ul></li><li><strong>程序执行的过程看不到</strong><ul><li>那我们想办法 “看到” 状态机的执行过程就好了！</li></ul></li></ul><h4 id="理解状态机执行-不是-调试-也是-调试" tabindex="-1"><a class="header-anchor" href="#理解状态机执行-不是-调试-也是-调试"><span>理解状态机执行：不是 “调试”，也是 “调试”</span></a></h4><ul><li><code>ssh</code>：使用 <code>-v</code> 选项检查日志</li><li><code>gcc</code>：使用 <code>-v</code> 选项打印各种过程</li><li><code>make</code>：使用 <code>-nB</code> 选项查看完整命令历史</li></ul><h4 id="调试-不仅是-调试器" tabindex="-1"><a class="header-anchor" href="#调试-不仅是-调试器"><span>调试：不仅是 “调试器”</span></a></h4><ul><li>Profiler: <code>perf</code> - “采样” 状态机</li><li>Trace: <code>strace</code> - 追踪系统调用</li></ul><h4 id="例-sys-cdefs-h-no-such-file-or-directory" tabindex="-1"><a class="header-anchor" href="#例-sys-cdefs-h-no-such-file-or-directory"><span>例: &#39;sys/cdefs.h&#39;: No such file or directory</span></a></h4><ul><li>(这看起来是用 <code>perror()</code> 打印出来的！)</li><li>问题分析 <ul><li><code>#include</code> = 复制粘贴，自然会经过路径解析</li><li>明明 <code>/usr/include/x86_64-linux-gnu/sys/cdefs.h</code> 是存在的 (<code>man 1 locate</code>)</li></ul></li></ul><h5 id="两种方法" tabindex="-1"><a class="header-anchor" href="#两种方法"><span>两种方法</span></a></h5><ul><li>日志: 运行时添加 <code>--verbose</code>选项</li><li>strace，直接看访问过的文件！</li></ul><h3 id="调试程序" tabindex="-1"><a class="header-anchor" href="#调试程序"><span>调试程序</span></a></h3><h4 id="gdb-状态机查看器" tabindex="-1"><a class="header-anchor" href="#gdb-状态机查看器"><span>GDB：状态机查看器</span></a></h4><ul><li>允许我们控制执行流、检查状态</li><li>而且原生支持 Python <ul><li>因此拥有众多前端：gdb-gui, cgdb, pwndbg, gdb-dashboard, vscode, ddd, ..</li><li>(我觉得最好用的还是自己按需轻量定制)</li></ul></li></ul><h4 id="使用-gnu-debugger" tabindex="-1"><a class="header-anchor" href="#使用-gnu-debugger"><span>使用 GNU Debugger</span></a></h4><ul><li>GDB: 最常用的命令在<a class="vp-link link vp-external-link-icon" href="./%E8%B0%83%E8%AF%95%E7%90%86%E8%AE%BA.assets/gdb-cheat-sheet.pdf" target="_blank" rel="noreferrer"><!--[-->gdb cheat sheet<!--]--></a><ul><li>打印贴在电脑前，调试时候看一遍，很快就大致记住了</li></ul></li></ul><h4 id="我们依旧需要-rtfm" tabindex="-1"><a class="header-anchor" href="#我们依旧需要-rtfm"><span>我们依旧需要 <a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/" target="_blank" rel="noopener noreferrer">RTFM</a></span></a></h4><ul><li>否则我们甚至不知道 gdb 有多强大</li></ul><h4 id="cheat-sheet-里没有的功能" tabindex="-1"><a class="header-anchor" href="#cheat-sheet-里没有的功能"><span>Cheat Sheet 里没有的功能</span></a></h4><ul><li>Text UI (我已经默认启动)</li><li>Stack, optimized code, macros, ...</li><li>Reverse execution</li><li>Record and replay</li><li>Scheduler</li></ul><h2 id="调试理论的应用" tabindex="-1"><a class="header-anchor" href="#调试理论的应用"><span>调试理论的应用</span></a></h2><p><strong>需求 → 设计 → 代码 → Fault → Error → Failure</strong></p><ul><li>“Technical Debt”: 每当你写出不好维护的代码，你都在给你未来的调试/需求变更挖坑 <ul><li>论敏捷开发与💩山代码</li></ul></li></ul><h3 id="调试理论-推论1" tabindex="-1"><a class="header-anchor" href="#调试理论-推论1"><span>调试理论: 推论1</span></a></h3><h4 id="需求-→-设计-→-代码-→-fault-→-error-→-failure" tabindex="-1"><a class="header-anchor" href="#需求-→-设计-→-代码-→-fault-→-error-→-failure"><span><!----> → Error → Failure</span></a></h4><ul><li><strong>写好代码</strong>：不要在写代码的时候忘记需求和设计</li><li>不言自明 (Self-explanatory) <ul><li>能通过字面知道需求 (流程)</li></ul></li><li>不言自证 (Self-evident) <ul><li>能通过字面确认代码和需求一致</li></ul></li></ul><h3 id="一个评判标准" tabindex="-1"><a class="header-anchor" href="#一个评判标准"><span><strong>一个评判标准</strong></span></a></h3><ul><li>AI 是否能正确理解/维护你的代码: <a href="http://git.nju.edu.cn/jyy/toybox" target="_blank" rel="noopener noreferrer">toybox</a></li></ul><blockquote><p>Programs are meant to be read by humans and only incidentally for computers to execute. (Donald E. Knuth)</p><p>程序首先是给人读的, 其次才是给机器去执行</p></blockquote><h3 id="调试理论-推论-2" tabindex="-1"><a class="header-anchor" href="#调试理论-推论-2"><span>调试理论：推论 (2)</span></a></h3><h4 id="需求-→-设计-→-代码-→-fault-→-error-→-failure-1" tabindex="-1"><a class="header-anchor" href="#需求-→-设计-→-代码-→-fault-→-error-→-failure-1"><span>需求 → 设计 → 代码 → <!----> → Failure</span></a></h4><ul><li><strong>做好测试</strong>：未测代码永远是错的 <ul><li>残酷的现实：相信自己写不对代码</li><li>LLM 一样经常犯 “傻” 错</li></ul></li></ul><h4 id="small-scope-hypothesis" tabindex="-1"><a class="header-anchor" href="#small-scope-hypothesis"><span>Small Scope Hypothesis</span></a></h4><blockquote><p>If a system does not have a counterexample (i.e., an error or a bug) for a certain property within a small scope (a limited size or configuration), then it is unlikely to have a counterexample in a larger scope. (Daniel Jackson)</p><p>如果一个系统在有限的范围（有限的大小或配置）内对某个特定属性没有反例（即错误或漏洞），那么它在更大的范围内也不太可能有反例。</p></blockquote><h3 id="调试理论-推论-3" tabindex="-1"><a class="header-anchor" href="#调试理论-推论-3"><span>调试理论：推论 (3)</span></a></h3><h4 id="需求-→-设计-→-代码-→-fault-→-error-→-failure-2" tabindex="-1"><a class="header-anchor" href="#需求-→-设计-→-代码-→-fault-→-error-→-failure-2"><span>需求 → 设计 → 代码 → Fault → <!----></span></a></h4><ul><li>测试的目的: 将隐藏的Fault暴露出来 变成可观测的Failure</li><li><strong>多写断言ASSERT</strong>：把代码中的 “隐藏性质” 写出来 <ul><li>机器总是对的, 但人总可能犯错→在你发现bug前, 描述正确代码应该有的性质, 用断言来表述他们</li><li>Error 暴露的越晚，调试越困难</li><li>追溯导致 assert failure 的变量值 (slice) 通常可以快速定位到 bug</li></ul></li></ul><blockquote><p>“There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies” (Tony Hoare)</p><p>构建软件设计有两种方式：一种方式是让它简单到明显没有缺陷；另一种方式是让它复杂到没有明显的缺陷</p><ul><li><strong>简单到无懈可击</strong>：第一种方法是设计一个极其简单明了的系统，简单到没有任何明显的缺陷或漏洞</li><li><strong>复杂到难以察觉缺陷</strong>：第二种方法是创建一个如此复杂和深奥的设计，以至于缺陷并不明显</li></ul></blockquote></div><!----><!----><!----></div></main><footer class="vp-doc-footer" data-v-50e98be9 data-v-f5809d15><!--[--><!--]--><div class="edit-info" data-v-f5809d15><div class="edit-link" data-v-f5809d15><a class="vp-link link no-icon vp-external-link-icon edit-link-button" href="https://github.com/yJader/JinBlog/edit/main/docs/blog/posts/调试理论.md" target="_blank" rel="noreferrer" data-v-f5809d15><!--[--><span class="vpi-square-pen edit-link-icon" aria-label="edit icon" data-v-f5809d15></span> 编辑此页<!--]--></a></div><!----></div><div class="contributors" aria-label="Contributors" data-v-f5809d15><span class="contributors-label" data-v-f5809d15>贡献者: </span><span class="contributors-info" data-v-f5809d15><!--[--><!--[--><span class="contributor" data-v-f5809d15>yJader_xx</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" data-v-f5809d15>yJader</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" data-v-f5809d15>yJader@mba</span><!----><!--]--><!--]--></span></div><nav class="prev-next" data-v-f5809d15><div class="pager" data-v-f5809d15><a class="vp-link link pager-link prev" href="/JinBlog/blog/g70sczk7/" data-v-f5809d15><!--[--><span class="desc" data-v-f5809d15>上一页</span><span class="title" data-v-f5809d15><!----><span data-v-f5809d15>presentation</span></span><!--]--></a></div><div class="pager" data-v-f5809d15><a class="vp-link link pager-link next" href="/JinBlog/blog/eaq3vgce/" data-v-f5809d15><!--[--><span class="desc" data-v-f5809d15>下一页</span><span class="title" data-v-f5809d15><!----><span data-v-f5809d15>mkdocs踩坑记录</span></span><!--]--></a></div></nav></footer><!----><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!--]--><button type="button" class="vp-back-to-top" aria-label="back to top" data-v-6fcf39b7 style="display:none;" data-v-9ccec6f7><span class="percent" data-allow-mismatch data-v-9ccec6f7>0%</span><span class="show icon vpi-back-to-top" data-v-9ccec6f7></span><svg aria-hidden="true" data-v-9ccec6f7><circle cx="50%" cy="50%" data-allow-mismatch style="stroke-dasharray:calc(0% - 12.566370614359172px) calc(314.1592653589793% - 12.566370614359172px);" data-v-9ccec6f7></circle></svg></button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="sign down" class="vp-sign-down" aria-hidden="true" data-v-6fcf39b7 style="display:none;" data-v-8cbe16af><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" data-v-8cbe16af><path d="m19 11l-7 6l-7-6" data-v-8cbe16af></path><path d="m19 5l-7 6l-7-6" opacity="0.6" data-v-8cbe16af></path></g></svg><footer class="vp-footer" vp-footer data-v-6fcf39b7 data-v-ec2d43d3><!--[--><div class="container" data-v-ec2d43d3><div class="message" data-v-ec2d43d3>Powered by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a></div><!----></div><!--]--></footer><!--[--><!--]--><!--]--></div><!----><!--]--><!--[--><!--]--><!--]--></div><script type="module" src="/JinBlog/assets/app-AuyBpmKP.js" defer></script></body></html>