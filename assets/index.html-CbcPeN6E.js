import{_ as n}from"./image-20220907231121965-BbRMBb0f.js";import{_ as a,c as i,a as e,o as l}from"./app-AuyBpmKP.js";const p={};function d(c,s){return l(),i("div",null,[...s[0]||(s[0]=[e('<h2 id="测试" tabindex="-1"><a class="header-anchor" href="#测试"><span>测试</span></a></h2><img src="'+n+`" alt="image-20220907231121965" style="zoom:33%;"><h2 id="一些书写习惯" tabindex="-1"><a class="header-anchor" href="#一些书写习惯"><span>一些书写习惯</span></a></h2><blockquote><p>仅供参考, 主要是自己好记</p></blockquote><h3 id="寄存器" tabindex="-1"><a class="header-anchor" href="#寄存器"><span>寄存器</span></a></h3><ul><li><code>ecx</code>: i</li><li><code>edi</code>: 数组基地址</li><li><code>eax</code> : 尽量不使用, 因为乘除计算时必须使用<code>eax</code>, 寄存器冲突不好解决 <ul><li>修改 : <code>imul 目标操作数, 源操作数</code> 可以直接对其他寄存器使用乘法,</li><li>但是除法的<code>idiv</code>没有这么简单</li></ul></li><li><code>ebx</code>, <code>edx</code>, <code>esi</code>: 随意</li></ul><h3 id="比较" tabindex="-1"><a class="header-anchor" href="#比较"><span>比较</span></a></h3><ul><li>比较习惯用有符号数的比较 (正如我们高级语言中常使用 int 而非 unsigned int) <ul><li><code>l</code>--less <code>g</code>--greater <code>e</code>--equal <code>n</code>--not</li><li>如 <code>&gt;= → jge</code></li></ul></li></ul><h2 id="基础模板" tabindex="-1"><a class="header-anchor" href="#基础模板"><span>基础模板</span></a></h2><h3 id="文件模板" tabindex="-1"><a class="header-anchor" href="#文件模板"><span>文件模板</span></a></h3><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-assembly"><span class="line"><span>include irvine32.inc</span></span>
<span class="line"><span>.data</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.code</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    ;主函数</span></span>
<span class="line"><span>main PROC</span></span>
<span class="line"><span>     ...</span></span>
<span class="line"><span>         exit</span></span>
<span class="line"><span>main ENDP</span></span>
<span class="line"><span>end main</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="fori" tabindex="-1"><a class="header-anchor" href="#fori"><span>fori</span></a></h3><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-assembly"><span class="line"><span>   mov ecx, 0 ; ecx:i</span></span>
<span class="line"><span>again:</span></span>
<span class="line"><span>       cmp ecx, 8</span></span>
<span class="line"><span>       jge final</span></span>
<span class="line"><span>       ... ; 循环体</span></span>
<span class="line"><span>       inc ecx</span></span>
<span class="line"><span>       jmp again</span></span>
<span class="line"><span>final:</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>注意不要重复使用寄存器, 如之前使用过 ecx, 可以在循环体前<code>push ecx</code>, 循环体后<code>pop ecx</code> 来暂存 ecx</li></ul><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-assembly"><span class="line"><span>   mov i, 0</span></span>
<span class="line"><span>again:</span></span>
<span class="line"><span>       cmp i, 8</span></span>
<span class="line"><span>       jge final</span></span>
<span class="line"><span>       ... ; 循环体</span></span>
<span class="line"><span>       inc i</span></span>
<span class="line"><span>       jmp again</span></span>
<span class="line"><span>final:</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="fori-forj" tabindex="-1"><a class="header-anchor" href="#fori-forj"><span>fori+forj</span></a></h3><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-assembly"><span class="line"><span>again_i:</span></span>
<span class="line"><span>          cmp  i, 8</span></span>
<span class="line"><span>          jge  final_i</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          mov  j, 0</span></span>
<span class="line"><span>again_j:</span></span>
<span class="line"><span>          cmp  j, 8</span></span>
<span class="line"><span>          jge  final_j</span></span>
<span class="line"><span>          ... ; forj循环体</span></span>
<span class="line"><span>          inc  j</span></span>
<span class="line"><span>          jmp  again_j</span></span>
<span class="line"><span>final_j:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          inc  i</span></span>
<span class="line"><span>          jmp  again_i</span></span>
<span class="line"><span>final_i:</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="函数模板-空" tabindex="-1"><a class="header-anchor" href="#函数模板-空"><span>函数模板(空)</span></a></h2><h3 id="函数模板–-void" tabindex="-1"><a class="header-anchor" href="#函数模板–-void"><span>函数模板–-void</span></a></h3><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-assembly"><span class="line"><span>myFun PROC  ;; void myFun(int* arr, int n) input:&lt;----函数传参时的的入栈顺序</span></span>
<span class="line"><span>   ;; return:void</span></span>
<span class="line"><span>; [ebp+4]: 调用函数位置的地址</span></span>
<span class="line"><span>; [ebp+8]: arr</span></span>
<span class="line"><span>; [ebp+12]: n</span></span>
<span class="line"><span> push ebp ; 暂存栈底寄存器</span></span>
<span class="line"><span> mov ebp, esp ; 修改栈底, 创建一个&quot;栈帧&quot;</span></span>
<span class="line"><span> pushad ; 存放所有寄存器</span></span>
<span class="line"><span></span></span>
<span class="line"><span> ... ; 代码段</span></span>
<span class="line"><span></span></span>
<span class="line"><span> popad ; 恢复所有寄存器</span></span>
<span class="line"><span> pop ebp ; 恢复栈底寄存器</span></span>
<span class="line"><span> ret 8 ; 返回原函数, 并pop8字节(去除栈中的arr和n)</span></span>
<span class="line"><span> ;; 也就是 传入2个4字节参数, 此时就ret 2*4(8)</span></span>
<span class="line"><span>myFun ENDP</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="函数模板—有返回值" tabindex="-1"><a class="header-anchor" href="#函数模板—有返回值"><span>函数模板—有返回值</span></a></h3><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-assembly"><span class="line"><span>myFun PROC  ;; myFun(int* arr, int n) input:&lt;----函数传参时的的入栈顺序</span></span>
<span class="line"><span>   ;; return:eax</span></span>
<span class="line"><span>; [ebp+4]: 调用函数位置的地址</span></span>
<span class="line"><span>; [ebp+8]: arr</span></span>
<span class="line"><span>; [ebp+12]: n</span></span>
<span class="line"><span> push ebp ; 暂存栈底寄存器</span></span>
<span class="line"><span> mov ebp, esp ; 修改栈底, 创建一个&quot;栈帧&quot;</span></span>
<span class="line"><span> sub esp, 4 ; 为返回值预留4个字节</span></span>
<span class="line"><span> pushad ; 存放所有寄存器</span></span>
<span class="line"><span></span></span>
<span class="line"><span> ... ; 代码段</span></span>
<span class="line"><span></span></span>
<span class="line"><span> mov [ebp-4], eax ; 暂存返回值</span></span>
<span class="line"><span> popad ; 恢复所有寄存器</span></span>
<span class="line"><span> mov eax, [ebp-4] ; 保存返回值到eax</span></span>
<span class="line"><span> add esp, 4 ; 去除预留个4字节</span></span>
<span class="line"><span> pop ebp ; 恢复栈底寄存器</span></span>
<span class="line"><span> ret 8 ; 返回原函数, 并pop8字节(去除栈中的arr和n)</span></span>
<span class="line"><span> ;; 也就是 传入2个4字节参数, 此时就ret 2*4(8)</span></span>
<span class="line"><span>myFun ENDP</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="常用函数" tabindex="-1"><a class="header-anchor" href="#常用函数"><span>常用函数</span></a></h2><h3 id="打印数组" tabindex="-1"><a class="header-anchor" href="#打印数组"><span>打印数组</span></a></h3><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-assembly"><span class="line"><span>include irvine32.inc</span></span>
<span class="line"><span>.data</span></span>
<span class="line"><span>    arr   dd 1, 2, 3, 4, 5, 6, 7, 8, 9</span></span>
<span class="line"><span>    n     dd 9</span></span>
<span class="line"><span>    space db &quot; &quot;, 0</span></span>
<span class="line"><span>.code</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    ;主函数</span></span>
<span class="line"><span>main PROC</span></span>
<span class="line"><span>          push   n</span></span>
<span class="line"><span>          push   offset arr</span></span>
<span class="line"><span>          call   print</span></span>
<span class="line"><span>          exit</span></span>
<span class="line"><span>main ENDP</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>print PROC                           ;; void print(int* arr, int n) input:&lt;----入栈顺序</span></span>
<span class="line"><span>    ;; return:void</span></span>
<span class="line"><span>    ; [ebp+4]: 调用函数位置的地址</span></span>
<span class="line"><span>    ; [ebp+8]: arr</span></span>
<span class="line"><span>    ; [ebp+12]: n</span></span>
<span class="line"><span>          push   ebp                 ; 暂存栈底寄存器</span></span>
<span class="line"><span>          mov    ebp, esp            ; 修改栈底, 创建一个&quot;栈帧&quot;</span></span>
<span class="line"><span>          pushad                     ; 存放所有寄存器</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          mov    ecx, 0              ; exc:i</span></span>
<span class="line"><span>          mov    edi, [ebp+8]        ; edi:arr</span></span>
<span class="line"><span>    again:</span></span>
<span class="line"><span>          cmp    ecx, [ebp+12]</span></span>
<span class="line"><span>          jge    final</span></span>
<span class="line"><span>          mov    eax, [edi+4*ecx]</span></span>
<span class="line"><span>          call   writeint</span></span>
<span class="line"><span>          lea    edx, space</span></span>
<span class="line"><span>          call   writeString</span></span>
<span class="line"><span>          inc    ecx</span></span>
<span class="line"><span>          jmp    again</span></span>
<span class="line"><span>    final:</span></span>
<span class="line"><span>          call   crlf</span></span>
<span class="line"><span>          popad                      ; 恢复所有寄存器</span></span>
<span class="line"><span>          pop    ebp                 ; 恢复栈底寄存器</span></span>
<span class="line"><span>          ret    8                   ; 返回原函数, 并pop8字节(去除栈中的arr和n)</span></span>
<span class="line"><span>    ;; 也就是 传入2个4字节参数, 此时就ret 2*4(8)</span></span>
<span class="line"><span>print ENDP</span></span>
<span class="line"><span></span></span>
<span class="line"><span>end main</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,25)])])}const m=a(p,[["render",d]]),b=JSON.parse('{"path":"/fzu_cs_course/assembly/template/","title":"一种基于irvine32.inc库的汇编模板|･ω･｀)","lang":"zh-CN","frontmatter":{"title":"一种基于irvine32.inc库的汇编模板|･ω･｀)","author":"zjj","createTime":"2024/06/30 18:34:22","permalink":"/fzu_cs_course/assembly/template/"},"readingTime":{"minutes":2.85,"words":854},"git":{"createdTime":1712149562000,"updatedTime":1764841213000,"contributors":[{"name":"yJader_xx","username":"","email":"yj1425840290@gmail.com","commits":1,"avatar":"https://gravatar.com/avatar/d114b38a3a1c3bc953fd1edf640e4ea41ad9e03ff609b52a5d7ee42d8d8da8d4?d=retro"},{"name":"yJader_r9p","username":"","email":"yj1425840290@gmail.com","commits":2,"avatar":"https://gravatar.com/avatar/d114b38a3a1c3bc953fd1edf640e4ea41ad9e03ff609b52a5d7ee42d8d8da8d4?d=retro"},{"name":"yJader@mba","username":"","email":"yjader@foxmail.com","commits":2,"avatar":"https://gravatar.com/avatar/92def0cdfefbca5d6297bdc419bf36d1d3e6f7ea47c613f809dff655a7536adb?d=retro"}]},"filePathRelative":"fzu_cs_course/汇编&接口/汇编模板.md","headers":[]}');export{m as comp,b as data};
