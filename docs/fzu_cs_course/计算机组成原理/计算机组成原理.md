# 第一章 计算机系统概述

![img](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/20210117160451896.png)

## 【复习提示】

本章是组成原理的概述，考查时易针对有关概念或性能指标出选择题，也可能综合后续章节的内容出有关性能分析的综合题。掌握本章的基本概念，是学好后续章节的基础。部分知识点在初学时理解不深刻也无须担忧，相信随着后续章节的学习，一定会有更为深入的理解。本章中读者要重点掌握各个性能指标的计算，这部分内容在历年真题中出现的频率很高。

学习本章时，请读者思考以下问题：

- 1)计算机由哪几部分组成？以哪部分为中心？
- 2)主频高的 CPU 一定比主频低的 CPU 快吗？为什么？
- 3)翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？
- 4)不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？

请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。

## 1.1 计算机发展历程 <略>

### 1.1.1 计算机硬件的发展

计算机系统=硬件+软件

计算机硬件的发展：

- 第一代计算机：(使用电子管)，
- 第二代计算机：(使用晶体管)，
- 第三代计算机：(使用较小规模的集成)，
- 第四代计算机：(使用较大规模的集成)，

已经经历了 4 代，计算机的速度越来越快，并且体积变得越来越小。 发展趋势：更微型、多用途；更巨型、超高速

> 晶体管之父：肖克利（1956 年诺贝尔物理学奖得主）1957 年，"八叛徒"创立了仙童半导体 1959 年，仙童半导体发明了“集成电路”1968 年，摩尔离开仙童，创立 intel1969 年，仙童销售部负责人桑德斯离开仙童，创立 AMD

摩尔定律，集成电路上的晶体管数量每 18 月就会翻一翻，所以每 18 月计算机的处理效率就会提高一倍。

### 1.1.2 计算机软件的发展

计算机软件技术的发展，促进计算机系统的发展。

计算机语言的发展经历了面向机器的机器语言和汇编语言、面向问题的高级语言。其中高级语言的发展真正促进了软件的发展，它经历了从科学计算和工程计算的 FORTRAN、**结构化程序设计的 PASCAL**到**面向对象的 C++和适应网络环境的 Java**。

同时，直接影响计算机系统性能提升的各种系统软件也有了长足的发展，特别是操作系统，如 Windows、UNIX、 **Linux**等。

### 1.1.3 计算机的分类与发展方向

可以分为：

- 电子模拟计算机和电子数字计算机。

数字计算机又可以按照用途分为：

- 专用计算机和通用计算机
- 通用计算机又分为：巨型机、大型机、中型机、小型机、微型机和单片机 6 类。

按照指令和数据流可以分为：

- 单指令流和单数据流系统（SISD），即传统的冯·诺依曼体系结构。
- 单指令流和多数据流系统（SIMD），包括阵列处理器和向量处理器系统。
- 多指令流和单数据流系统（MISD），这种计算机实际上不存在。
- 多指令流和多数据流系统（MIMD），包括多处理器和计算机系统。

## 1.2 计算机系统层次结构

### 1.2.1 计算机系统的组成

计算机系统由硬件系统和软件系统共同构建起来

### 1.2.2 计算机硬件的基本组成

#### 1.早期的冯·诺依曼机

> 美籍匈牙利科学家冯·诺依曼最先提出“程序存储”的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯·诺依曼又被称为“现代计算机之父”。
>
> 什么是存储程序原理？按此原理，计算机应具有哪几大功能？
>
> - “<font color='#66ccff'>程序存储</font>”：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。即按地址访问并顺序执行指令
>
> - 计算机按照此原理应具有 5 大功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能

冯诺曼体系结构特点:

1. 计算机硬件系统由五大部件组成 (存储器、运算器、控制器、输出设备、输入设备)
2. 指令和数据以同等地位存于存储器，可按地址寻访
3. 指令和数据用==二进制== 表示
4. 指令由操作码和地址码组成
5. 存储程序
6. 以**运算器**为中心

> 早期的冯·诺依曼机以运算器为中心，且是单处理机，<strong>最根本的特征</strong>是采用“<strong>存储程序</strong>”原理，基本工作方式是<font color="blur">控制流驱动方式！</font>

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/20210117142226114.png" alt="img" style="zoom:50%;" />

#### 2.现代计算机的组织结构

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/20210117142257606.png" alt="img" style="zoom:50%;" />

#### 3.计算机的功能部件

主机：主存、运算器、控制器

 <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/2021011714554763.png" alt="img" style="zoom:50%;" />

##### 五大部分：

1. <font color='#66ccff'>输入设备</font> : 是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等
2. <font color='#66ccff'>输出设备</font> : 就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印机
3. <font color='#66ccff'>存储器</font> : 存储器分为<font color='#66ccff'>主存储器</font>(<font color='#66ccff'>内存储器</font>，CPU 能直接访问) 和 <font color='#66ccff'>辅助存储器</font>(<font color='#66ccff'>外存储器</font>，协助主存储器记忆更多的信息，辅助存储器的信息需要导入到主存储器中，才可以被 CPU 访问)。
   - 主存储器的工作方式是==按存储单元的地址进行存取== ，这种存取方式称为**按地址存取方式** (相联存储器既可以既可以按照地址寻址，又可以按照内容寻址，为了与传统存储器区别，又称为内容寻址的存储器！)
   - 主存储器是由<font color='#66ccff'>地址寄存器</font>(MAR)，<font color='#66ccff'>数据寄存器</font>(MDR)，<font color='#66ccff'>存储体</font>，时序控制逻辑 组成
   - 地址寄存器存放访存地址，经过地址译码后找到所选的存储单元。
   - 数据寄存器，是存储器与其他部件的中介，用于暂存要从存储器读或写的信息。
   - 时序控制逻辑用于产生存储器操作所需的各种时序信号。
   - 在现代 CPU，MAR 和 MDR 是在 CPU 中的。
4. <font color='#66ccff'>运算器</font> : 是计算机的运算单元，用于算术运算和逻辑运算
   - 运算器的核心单元是算术逻辑单元(ALU)
5. <font color='#66ccff'>控制器</font> : 控制器是计算机的指挥中心，有其指挥各部件自动协调第进行工作，现代计算机将运算器和控制器集成到一个芯片上，合成为中央处理器，简称 CPU。
   - 有程序计数器(PC)、指令寄存器(IR)和控制单元(CU)。
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/20210117143001482.png" alt="在这里插入图片描述" style="zoom:50%;" />

一般将运算器和控制器集成到同一个芯片上，称为中央处理器(CPU)。CPU 和主存储器共同构成主机，而除主机外的其他硬件装置(外存、I/O 设备等)统称为外部设备，简称外设。

图 1.4 所示为冯・诺依曼结构的模型机。CPU 包含 ALU、通用寄存器组 GPRs、标志寄存器、控制器、指令寄存器 IR、程序计数器 PC、存储器地址寄存器 MAR 和存储器数据寄存器 MDR。图中从控制器送出的虚线就是控制信号，可以控制如何修改 PC 以得到下一条指令的地址，可以控制 ALU 执行什么运算，可以控制主存是进行读操作还是写操作(读/写控制信号)。 <img src="https://img-blog.csdnimg.cn/20210121090349881.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

CPU 和主存之间通过一组总线相连，总线中有地址、控制和数据 3 组信号线。MAR 中的地址信息会直接送到地址线上，用于指向读/写操作的主存存储单元；控制线中有读/写信号线，指出数据是从 CPU 写入主存还是从主存读出到 CPU,根据是读操作还是写操作来控制将 MDR 中的数据是直接送到数据线上还是将数据线上的数据接收到 MDR 中。

### 1.2.3 计算机软件的分类

#### 1.系统软件和应用软件

计算机软件，一般分为系统软件和应用软件

- 系统软件包括 操作系统，数据库管理系统，语言处理系统(比如编译器)，分布式软件系统，网络软件系统，标准库系统，服务性系统(比如连接程序)。
- 应用软件包括各种科学计算类程序，工程设计类程序，数据统计与处理程序。

注意：数据库管理系统和数据库系统是有区别的。数据库管理系统是系统软件。而数据库系统一般是由数据库，数据库管理系统，数据库管理员和应用系统构成。所以只能说它里面有系统软件，但并不能说它为系统软件。

#### 2.三个级别的语言

- **机器语言**。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。机器语言是计算机==唯一可以直接识别和执行的语言== 。
- **汇编语言**。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。
- **高级语言**。高级语言(如 C、C++、Java 等)是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。

由高级语言转换到汇编语言的过程叫做<font color='#66ccff'>编译</font>，由汇编语言转换到机器语言的过程叫做<font color='#66ccff'>汇编</font>，边翻译边执行的叫做<font color='#66ccff'>解析</font>。

机器语言是唯一可以控制 cpu 的语言，因为它的符号不利于人识别和书写，为了方便理解和记忆，将机器语言换一些通俗易懂的符号，这就变成了汇编语言。一般来说在在编译器中高级语言先转换为汇编在转换为机器语言，也有直接转换为机器语言的情况。

### 1.2.4 计算机的工作过程

#### 2.指令执行过程的描述(点击链接，视频 20min 处有详细讲解)

![img](https://img-blog.csdnimg.cn/20210117172058667.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210117172600539.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210117172909779.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210117173204649.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210117173316604.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210117151423946.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210117173446275.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

> <font color="blur" size="4"> IR</font>存放当下<strong>欲执行的指令</strong>；<font color="blur" size="4">PC</font>存放<strong>下一条指令的地址</strong>；<br><font color="blur" size="4">MAR</font>存放<strong>欲访问的存储单元地址</strong>；<font color="blur" size="4">MDR</font>存放<strong>从存储单元取来的数据</strong>！<br><font color="blur" size="4">地址译码器</font>是<strong>主存的构成部分，不属于 CPU</strong>；地址寄存器虽然一般属于主存，但是现代计算机中绝大多数 CPU 内集成了地址寄存器！<br>关于 CPU 存取速度的比较：寄存器（CPU 内部）&gt; Cache(高速的 SRAM) &gt; 内存 （SDRAM）

![img](https://img-blog.csdnimg.cn/20210117132729679.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) 上图是计算机的工作流程，首先 PC 将指令地址发送给 MAR，MAR 根据地址在存储体中找到指令数据存放在 MDR 中，之后 MDR 将指令存放在 IR 中，取指令结束，之后指令中的操作码进入 CU 中，地址码重复上述取指令步骤，将数据发送到 ACC 中，执行指令结束。注意区分指令和数据的依据:指令周期的不同阶段

## 1.3 计算机性能指标

<img src="https://img-blog.csdnimg.cn/20210117153043725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

1. **机器字长**
   - 计算机的位数（机器字长），表示计算机进行一次整数运算(即定点整数运算)所能处理的二进制数据的位数。计算机字长通常选定为字节(8 位)的整数倍，通常是 2,4,8 倍。不同的计算机，字节可能不同

> <font color="blur" size="4">机器字长、指令字长、存储字长的区别和联系是什么？</font>
>
> - 机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。
> - 指令字长：一个指令字中包含的二进制代码的位数。
> - 存储字长：一个存储单元存储的二进制代码的长度。等于 MDR 的位数， 它们都必须是字节的整数倍。
> - 数据字长：数据总线一次能传送信息的位数，它可以不等于 MDR 的位数。
>
> 指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 次访存来取出一条指令，因此取指周期为机器周期的 2 倍；若指令字长等于存储字长，则取指周期等于机器周期。
>
> 早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。
>
> 请注意 64 位操作系统是指特别为 64 位架构的计算机而设计的操作系统，它能够利用 64 位处理器的优势。但 64 位机器既可以使用 64 位操作系统，又可以使用 32 位操作系统。而 32 位处理器是无法使用 64 位操作系统的。

2. 数据通路带宽 : 数据总线一次所能传送信息的位数。
3. 主存容量 : MAR 的位数反映存储单元的个数，如 MAR 为 16 位，表示存储单元为 216 = 64K;若 MDR 为 32 位，则存储容量为 216x32
   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/20210117151129290.png" alt="img" style="zoom:50%;" />

4. 运算速度

   1. 吞吐量和响应时间
      - <font color='#66ccff'>吞吐量</font> : 指系统在单位时间内处理请求的数量 ；从用户观点看，它是评价计算机系统性能的综合参数！
      - <font color='#66ccff'>响应时间</font>，指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结构的等待时间。
   2. CPU 时钟周期和主频。
      - <font color='#66ccff'>CPU 时钟周期</font> : 通常为节拍脉冲或 T 周期，即主频的倒数，它是 CPU 中最小的时间单位，每个动作至少需要 1 个时钟周期。
      - <font color='#66ccff'>主频(CPU 时钟频率)</font> : 机器内部主时钟的频率，是衡量机器速度的重要参数。
   3. <font color='#66ccff'>CPI</font>（Clock cycle Per Instruction）: 即执行一条指令所需的时钟周期数。

   4. <font color='#66ccff'>CPU 执行时间</font> : 指运行一个程序所花费的时间。

      - $CPU执行时间 = CPU时钟周期数/主频 = (指令条数xCPI)/主频$
        - CPU 的性能取决于三个要素:主频、CPI 、指令条数

   5. <font color='#66ccff'>IPS</font>(Instructions Per Second) $=主频/平均CPI$，每秒执行多少指令

      <font color="66ccff">MIPS</font>(Million Instructions Per Second) : 即每秒执行多少百万条指令

      - $MIPS = 指令条数/(执行时间\times 10^6) = 主频/(CPI\times 10^6)$

## 1.4 本章开头提出的问题回答

1. 计算机由哪几部分组成？以哪部分为中心？

   - 计算机由运算器、控制器、存储器、输入设备及输出设备五大部分构成
   - 现代计算机通常把运算器和控制器集成在一个芯片上，合称为中央处理器(CPU)。而在微处理器面世之前(早期的冯·诺依曼机)，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。
   - 随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量 IO 设备的速度和 CPU 的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。现代计算机已经发展为以存储器为中心，使 IO 操作尽可能地绕过 CPU,直接在 IO 设备和存储器之间完成，以提高系统的整体运行效率。

2. 主频高的 CPU 一定比主频低的 CPU 快吗？为什么？

   - 衡量 CPU 运算速度的指标有很多，不能以单独的某个指标来判断 CPU 的好坏。
   - CPU 的主频，即 CPU 内核工作的时钟频率。CPU 的主频表示 CPU 内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为 CPU 的运算速度还要看 CPU 的流水线的各方面的性能指标（架构、缓存、指令集、CPU 的位数、 Cache 大小等）。
   - 由于主频并不直接代表运算速度，因此在一定情况下很可能会出现主频较高的 CPU 实际运算速度较低的现象

3. 翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？

   - 翻译程序是指把高级语言源程序翻译成机器语言程序（目标代码）的软件。

   - 翻译程序有两种：一种是编译程序，它将高级语言源程序一次全部翻译成目标程序，每次执行程序时，只需执行目标程序，因此只要源程序不变，就无须重新翻译，请注意同一种高级语言在不同体系结构下，编译成目标程序是不一样的，目标程序与体系结构相关，但仍不是计算机硬件能够直接执行的程序。

   - 另一种是解释程序，它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。

   - 汇编程序也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。汇编语言是种面向机器的低级语言，是机器语言的符号表示，与机器语言一一对应。

   - 编译程序与汇编程序的区別：若源语言是诸如 C、C++、Java 等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序。

4. 不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？
   - 机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。其中机器语言可以被硬件直接执行。

## 1.5 常见问题

### 1.同一个功能既可以由软件实现又可以由硬件实现吗？

- 软件和硬件是两种完全不同的形态，硬件是实体，是物质基础；软件是一种信息，看不见、摸不到。但在逻辑功能上，软件和硬件是等效的。因此，在计算机系统中，许多功能既可以由硬件直接实现，又可以在硬件的配合下由软件实现。
- 一个最大的区别就是，硬件实现比软件实现的速度快很多，但是成本也高！所以，芯片在流片之后，如果发现 bug 可以用软件修复就用软件修复！
- 例如，乘法运算既可用专门的乘法器（主要由加法器和移位器组成）实现，也可用乘法子程序（主要由加法指令和移位指令等组成）来实现。

### 2.翻译程序、汇编程序、编译程序、解释程序的区别和联系是什么？

- 见本章开头提出的问题

### 3.什么是透明性？透明是指什么都能看见吗？

- 在计算机领域中，站在某类用户的角度，若感觉不到某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。这与日常生活中的“透明”概念(公开、看得见)正好相反。 例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。 在 CPU 中，IR、MAR 和 MDR 对各类程序员都是透明的。

### 4.机器字长、指令字长、存储字长的区别和联系是什么？

- **机器字长**：计算机能直接处理的二进制数据的位数，机器字长**一般等于内部寄存器的大小**，它决定了**计算机的运算精度**。
- **指令字长**：一个指令字中包含的二进制代码的位数。
- **存储字长**：一个存储单元存储的二进制代码的长度。等于 MDR 的位数， 它们都必须是字节的整数倍。
- **数据字长**：数据总线一次能传送信息的位数，它可以不等于 MDR 的位数。

指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 次访存来取出一条指令，因此取指周期为机器周期的 2 倍；若指令字长等于存储字长，则取指周期等于机器周期。 早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。

随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。

请注意 64 位操作系统是指特别为 64 位架构的计算机而设计的操作系统，它能够利用 64 位处理器的优势。但 64 位机器既可以使用 64 位操作系统，又可以使用 32 位操作系统。而 32 位处理器是无法使用 64 位操作系统的。

### 5.计算机体系结构和计算机组成的区别和联系是什么？

- 计算机体系结构是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性。
- 计算机组成是指如何实现计算机体系结构所体现的属性，它包含对许多对程序员来说透明的硬件细节。

例如，指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数如何运算等都属于组成的问题。因此，当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可以认为它们的组成方式是不同的。

例如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。（简言之，看**有没有**这个属性，就是**结构**问题；看**怎么实现**，就是**组成问题**）

许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。例如， IBM System/370 结构就包含了多种价位和性能的机型。

### 6.基准程序执行得越快说明机器的性能越好吗？

- 一般情况下，基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。

![img](https://img-blog.csdnimg.cn/20210118085022452.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

# 第二章 数据的表示与运算

## 【复习提示】

本章内容较为繁杂，由于计算机中数的表示和运算方法与人们日常生活中的表示和运算方法不同，因此理解也较为困难。纵观近几年的真题，不难发现 unsigned、shot、int、long、foat、 double 等在 C 语言中的表示、运算、溢出判断、隐式类型转换、强制类型转换、IEEE754 浮点数的表示，以及浮点数的运算，都是考研考查的重点，需要牢固掌握。

在学习本章时，请读者思考以下问题：

- 1)在计算机中，为什么要采用二进制来表示数据？
- 2)计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。
- 3)字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？
- 4)用移码表示浮点数的阶码有什么好处？

请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。

## 2.1 数据与文字的表示方法

### 2.1.1 数制与编码

> 这一节抄的 很基础 不用看了

#### 一. 进位计数制及其相互转化

##### 知识点回顾与重点考点（如果知道了，就不用看了）

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/20210117191955803.png" alt="img" style="zoom: 50%;" /> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/20210117183943164.png" alt="img" style="zoom: 50%;" /> ![img](https://img-blog.csdnimg.cn/20210117185238778.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210117185618834.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210117185725631.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

十进制数转换成二进制数 对一个数的整数部分和小数部分分别进行处理 ，合并各自得出的结果

- 整数部分 : <font color='#66ccff'>除基取余法</font>： 采用将十进制数连续除以２ 提取余数 的方法，提取的余数 依此为二进制的低位、次低位．．．高位 。直到商=0 为止

  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230226201826218.png" alt="image-20230226201826218" style="zoom: 50%;" />

- 小数部分：<font color='#66ccff'>乘基取整法</font>： 采用将十进制小数部分连续乘以２提取乘积中整数的方法，提取的整数依此是小数部分的最高位、次高位．．．

  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230226201858967.png" alt="image-20230226201858967" style="zoom:50%;" />

- 拼凑法(减权定位法) : 依次 与二进制权位比较 ，够减的为 1，不够为 0

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/20210117191021486.png" alt="img" style="zoom: 50%;" />

#### 二. BCD 码（Binary-Code Decimal 码）<略>

##### 知识回顾与重要考点

![img](https://img-blog.csdnimg.cn/20210117193657777.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

- 详见 [数电](../数字电路与逻辑设计/数字电路与逻辑设计.md# 3.1 BCD 码)

#### 三. 字符与字符串

![img](https://img-blog.csdnimg.cn/20210117193803381.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

1. 字符编码 ASCII 码

![img](https://img-blog.csdnimg.cn/20210117194317905.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210117194843132.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210117200407446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

2. 字符串

![img](https://img-blog.csdnimg.cn/20210117195816708.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210117195936696.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

##### 知识回顾与重要考点

![img](https://img-blog.csdnimg.cn/20210117200115324.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

#### 四. 校验码

![img](https://img-blog.csdnimg.cn/20210117201426544.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

> 任意两个码字之间最少变化的二进制位数称为<font color="blur" size="4">码距</font>，码距大于等于 2 的数据校验码开始具有检错的能力。<font color="blur" size="4">码距越大，检错、纠错能力越强</font>。奇偶校验码的码距等于 2,可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能检测出偶数位错误；海明码的码距大于 2,因此不仅可以发现错误，还能指出错误的位置。<font color="blur" size="4">仅靠增加奇偶校验位的位数不能提高正确性，还要考虑码距</font>。<br>具有检、纠错能力的数据校验码的实现原理：在编码中，除合法码字外，再加入一些非法码字，当某个合法码字出现错误时，就变为非法码字。合理安排非法码字的数量和编码规则就能达到纠错的目的。

##### 1.奇偶校验码

原编码上加一个校验位，码距等于 2！ ![img](https://img-blog.csdnimg.cn/20210117201754590.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210117202320100.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) 知识回顾与重要考点

![img](https://img-blog.csdnimg.cn/20210117202609126.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

##### 2.海明（汉明）校验码

![img](https://img-blog.csdnimg.cn/20210118080256138.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210118080501589.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210118081711303.png?k,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210118081852709.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210118081938619.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/2021011808201964.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210118082050560.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

##### 3. 循环冗余校验（CRC）码

终于知道了《UVM 实战》中的 CRC 校验是什么回事了！ ![img](https://img-blog.csdnimg.cn/2021011808234085.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210118084534498.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210118082908894.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210118083019225.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210118083336843.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210118083714247.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

> CRC 校验码是可以纠错的，前面这个是因为信息位太长

![img](https://img-blog.csdnimg.cn/20210118084033953.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210118084104650.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

### 2.1.2 定点数的表示

#### 一. 数据的表示

1. 真值：根据书写习惯，用正负号加绝对值表示的数值。 **一般用 X 表示** 。
2. 机器数：计算机内使用的，便于机器处理的数值，包括无符号数和有符号数。
   - 无符号数：整个机器字的全部二进制位均为数值位，相当于数的绝对值
   - 有符号数：将数的**符号位**一起数码化 ，符号位放在有效数字的前面
3. 数据格式 : 根据小数点的位置是否固定 ，计算机中常用的数据表示格式有两种 **定点格式** & **浮点格式**

#### 二. 定点数的表示

1. 定点数定义：约定机器中所有数据的小数点位置是固定不变的。通常将数据表示成纯小数或纯整数。
2. 设 n+1 位定点数$x=x_n x_{n-1} x_{n-2}... x_0$ ，则
   - 定点整数 : 用于表示纯整数，小数点位置隐含固定在**最低位**之后， 最高位为符号位
     - 机器字长为 n+1 位, 纯整数表示范围为 : $-(2^n-1) \leq |x|\leq 2^n-1$
     - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230226211337955.png" alt="image-20230226211337955" style="zoom: 33%;" />
   - 定点小数 : 用于表示纯小数， 小数点隐含固定在最高数据位的左边， 整数位则用于表示符号位
     - 机器字长为 n+1 位， 纯小数的表示范围为：$-(1-2^{-n}) \leq x\leq 1-2^{-n} $
     - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230226211641732.png" alt="image-20230226211641732" style="zoom: 33%;" />

#### 三. 数的机器码表示 (原 反 补 移)

1. 真值与机器数

   - 真值：用正负号加绝对值表示的数值。
   - 机器数：将数符一起数码化的数。常用机器数包括 **原码**、**补码**、**反码**和**移码**表示法。

   - 机器数形式的二进制位数因受机器字长的限制，其数的表示范围和精度相应受到限制 ，无法表示时便产生==溢出== 。

2. 原码表示法 $\textcolor{#66ccff}{[X]_原}$

   - 定义 : 设原码形式为$x=x_n x_{n-1} x_{n-2}... x_0$ **n+1 位字长**的原码为
     - 小数 : $[X]\_原 = \begin{cases}X&0\leq X<1\\ 1-X=1+|X|&-1<X\leq 0\end{cases};\quad 范围:-(1-2^{-n}) \leq x\leq 1-2^{-n} $
     - 整数 : $[X]_原 = \begin{cases}X&0\leq X<2^n\\ 2^n-X=2^n+|X|& -2^n<X\leq 0\end{cases}\quad 范围: -(2^n-1) \leq |x|\leq 2^n-1$
   - 表示方法： 最高位表示数的符号，其他位表示数值位
     - 符号位： 0 －正数; 1 －负数
     - 数值位：与绝对值相同
   - 真值零的原码有两种 : $[+0]_原 = \textcolor{#ee0000}{0}0000; [-0]_原 = \textcolor{#ee0000}{1}0000$

3. 反码表示法 $\textcolor{#66ccff}{[X]_反}$

   - 定义 : 正数反码与原码相同，负数的反码将数==除符号位外按位求反==
   - 反码的特点：0 的反码也有两个，$[+0]*反 = \textcolor{#ee0000}{0}0000; [-0]*反 =\textcolor{#ee0000}{1}1111 $。
     反码的数值范围与原码相同

4. 补码表示法 $\textcolor{#66ccff}{[X]_补}$

   - 定义 : 把某数 X 加上模数 M, 称为以 M 为模的 X 的补码 $[X]_补 = (M+X)_{模M}$
     - 在机器内, 字长为 n+1 的整数的模为$2^{n+1}$, 小数的模为 2
     - 小数 : $[X]\_补 = \begin{cases}X&0\leq X<1\\ 2+X=2-|X|&-1<X\leq 0\end{cases};\quad 范围:\textcolor{#ee0000}{-1} \leq x\leq 1-2^{-n} $
     - 整数 : $[X]_原 = \begin{cases}X&0\leq X<2^n\\ 2^{n+1}+X=2^{n+1}-|X|& -2^n<X\leq 0\end{cases}\quad 范围: \textcolor{#ee0000}{-2^n} \leq |x|\leq 2^n-1$
       - 这表示==补码无法表示$-(-2^n) $== , 不存在$2^n$与之对应
   - 0 的补码只有一个 $0,0000$ , 之前的$1,0000 = [-2^n]_补(整数) / =[-1]_补(小数)$
   - 补码**正负转换**: 连同符号位取反+1

5. 补码的转换

   - 原码转化成补码方法：
     - 正数的补码与原码相同
     - 负数 :
       法 ① 求得该数的反码，然后在末位加 1
       法 ② 符号位不变，尾数部分**自右向左**，第一个 1 及以前的各位 0 保持不变，以后的各位按位取反
   - 补码转换成原码、真值方法：
     - 正数的原码与补码相同；
     - 负数时，符号位不变，尾数先按位取反，然后在末位加 1
     - 将原码的符号位用“+”, “-”号表示即为真值
   - 上述转换不包括 0 及补码的负数最小值
   - 补码转换十进制真值的方法：
     - 设补码形式为$x=x_n x_{n-1} x_{n-2}... x_0$
       整数：$x = -2^n x_n + \sum^{n-1}_{i=0}2^i x_i$
       小数：$x = (-1 )x_n + \sum^{0}_{i=n-1}2^{i-n} x_i$
     - 上述符号直接由运算得到 不用手动加

6. 移码表示法 $\textcolor{#66ccff}{[X]_移}$

   - 移码是在真值 X 上加上一个常数（偏移量），相当于 X 在数轴上向正方向偏移了若干单位。通常，当字长为 n+1 时，这个偏移量取$2^n$
   - 定义：计算机中对 k+1 位字长的带符号数，其==真值== X 所对应的移码为 :
     - $[X]_移 = 2^k+X, -2^k\leq X\leq 2^k-1$
   - 移码的特点
     1. 移码的符号位与原码、补码**相反** 1 为正， 0 为负
     2. X 的移码和补码**符号位相反 其余位相同**, 故移码可以先求数的补码，再将符号取反即得
     3. 0 的移码也只有一个， $[0]\_移 =10000000 $
     4. 移码一般用于浮点数的阶码表示
     5. 移码一般以整数形式出现，其数值范围与补码相同

7. n+1 位(以 5 位为例)字长的数的比较

   | 机器码类型   | 最小值                      |                               |     | 0             |     | 最大值  |
   | ------------ | --------------------------- | ----------------------------- | --- | ------------- | --- | ------- |
   | 真值(十进制) | $-2^n$ (原码, 反码无法表示) | $-2^n+1$ (原码, 反码的最小值) | …   | 0(只有一个 0) | …   | $2^n-1$ |
   | 补码         | 1,0000                      | 1,0001                        | …   | 0,0000        | …   | 0,1111  |
   | 移码         | 0,0000                      | 0,0001                        | …   | 1,0000        | …   | 1,1111  |

### 2.1.3 浮点数的表示

#### 一. 基本的浮点数

1. <font color='#66ccff'>浮点表示法</font>： 数的计阶表示方法，把数的范围和精度分开表示的方法，小数点的位置随阶数的不同而浮动。
   - 设任意一个进制数Ｎ用计阶法表示为：$Ｎ＝Ｒ^e\cdot Ｍ$
   - Ｍ ：<font color='#66ccff'>尾数</font> ，规定是一个纯小数，且计算机中一般约定为最高有效位为 1 ，称为<font color='#66ccff'>规格化</font> 。
   - e ：指数 ，是一个整数，计算机中称为 <font color='#66ccff'>阶码</font> 。
   - R ：比例因子的<font color='#66ccff'>基数</font> ，计算机中一般为 2，隐含表示
2. 实用浮点数格式 (以 32 位浮点数为例)
   - ![image-20230305114924879](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230305114924879.png)
   - Ｓ: 浮点数的<font color='#66ccff'>符号位</font>; 1 位; 0 表示正数, 1 表示负数
   - Ｍ : <font color='#66ccff'>尾数</font>; 23 位 ，小数点放在尾数域的最前面
   - Ｅ: <font color='#66ccff'>阶码</font>: 8 位 ，一般用==移码== 表示，其**真值**记为 e
     - 8 位移码表示范围 : $-128\leq e \leq127$
     - 阶码(移码)E 即为真值 e 添加上偏移量后的机器码, 有 $E = e+2^{k-1} = e + 2^{7}$
   - 所以一个**非规格化**的 32 位浮点数 x 的真值可表示为：$x = (-1)^s\times (0.M)\times 2^{E-128}$

#### 二. 规格化浮点数

1. 规格化的尾数
   - 当尾数值不为 0 时，在用**原码表示尾数**的情况下， 尾数域最高位必须为 1 (即 $|M|\geq 0.5$)
   - 若用补码表示尾数
     - 正数，尾数 最高位为 1 ，如 0.1011
     - 负数，尾数最高位为 0 ，如 1.0010
     - 即补码尾数的规格化, <font color='orange'>首位必须与符号位相反</font>
2. 规格化的目的:
   1. 保证浮点数表示的唯一性；
      - 如 $0.001001 = 0.01001\times 2^{-1} \stackrel {规格化}\Longrightarrow 0.1001\times 2^{-2}$
   2. 保留更多地有效数字，提高运算的精度
   3. 但是会损失表示范围

#### 三. IEEE754 标准的浮点数

1. IEEE754 标准

   - 32 位表示法<font color='orange'>(float)</font>: 1 位符号, 8 位阶码, 23 位尾数 ![image-20230305121318625](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230305121318625.png)
   - 64 位表示法<font color='orange'>(double)</font>: 1 位符号, 11 位阶码, 52 位尾数 ![image-20230305121323933](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230305121323933.png)

   - S (sign) : 浮点数的<font color='#66ccff'>符号位</font>; 1 位; 0 表示正数, 1 表示负数
   - M (significand / mantissa): <font color='#66ccff'>尾数</font>; 23 / 52 位 ，用**<font color='#66ccff'>规格化</font>小数原码**表示, 小数点放在尾数域的最前面, 小数点前第一位 1==隐含==
   - E (exponent): <font color='#66ccff'>阶码</font>: 8 位 ，一般用==特殊的移码== 表示，其**真值**记为 e, 同样需要进行<font color='#66ccff'>规格化</font>

     - $E = e+2^{k-1} \textcolor{#ee0000}{-1} \quad 即E = e(真值) + 127\ /\ 1023$ <font color='orange'>(<font color='#EE0000'>-1</font>: 隐藏位)</font>

       - $2^{k-1}-1$: 特殊的移码偏置值

     - e 的数值范围为 $-126\leq e \leq 127$

       - <font color='orange'>E 不能全为 0, 即 e~min~=1-127 = -126; </font>

         <font color='orange'>也不能全为 1, 即 e~max~ = 254-127 = 127</font>

       - ==偷懒== : 真值 → 补码(从右往左, 第一个 1 之后的位取反)→ 移码(符号位和补码相反, 此时为真值+128) → -1 的 IEEE754 的阶码

2. IEEE754 标准 机器码 → 真值

   - 32 位 : $真值x = (-1)^s\times (1.M)\times 2^{E-127}$
   - 64 位 : $真值x = (-1)^s\times (1.M)\times 2^{E-1023}$

3. 754 标准浮点数的特殊情况 (无穷与零)

   | 值的类型                                                                | 符号 | 阶码      | 尾数 | 值  |
   | ----------------------------------------------------------------------- | ---- | --------- | ---- | --- |
   | 正零                                                                    | 0    | 0         | 0    | 0   |
   | 负零                                                                    | 1    | 0         | 0    | -0  |
   | <font color='#66ccff'>非规格化数</font>: 用于表示 0,以及非常靠近 0 的数 | s    | 0         | ≠0   |     |
   | ↑ 与之相对应的: <br />规格化数(普通浮点数)                              | s    | ≠0 & ≠255 | m    |     |
   | 正无穷大                                                                | 0    | 全 1(255) | 0    | ∞   |
   | 负无穷大                                                                | 1    | 全 1(255) | 0    | -∞  |
   | NaN(非数字)                                                             |      | 全 1(255) | ≠0   |     |

   - 阶码不能全为 1
   - <font color='#66ccff'>非规格化数&规格化数</font>
     - 非规格化数, 尾数前隐藏位为 0
       即取值范围: [0.00000000000000000000000, 0.11111111111111111111111] ~B~→[0,1)(十进制)~D~
     - 规格化数, 尾数前隐藏位为 1
       即取值范围: [1.00000000000000000000000, 1.11111111111111111111111] ~B~→[1,2)~D~
   - 非规格化数的==溢出== :
     - `0 00000000 11111111111111111111111` 这是非规格数的最大值 $(1-2^{-22})*2^{-126}$
     - 再+1: `0 00000001 00000000000000000000000`变为规格数的最小值 $1*2^{-126}$ <font color='orange'>二者紧密连接</font>

4. > 【例】 若浮点数 x 的 754 标准存储格式为$(41360000)_{16}$求其浮点数的十进制数值

   - 展开十六进制 : $0\textcolor{#ee0000}{100\ 0001\ 0}011\ 0110\ 0000\ 0000\ 0000\ 0000$
   - 指数 $e = 阶码-127 = 10000010 - 01111111 = 0000 0011 = (3)\_{10} $
   - 尾数 $1.M = 1.011\ 0110\ 0000\ 0000\ 0000\ 0000 = 1.011011$
   - 浮点数 $真值x = (-1)^s\times (1.M)\times 2^{E-127} = +(1.011011)\times 2^3 = +1011.011 = (11.375)_{10}$

5. > 【例】 将$(20.59375)_{10}$转换成 754 标准的 32 位浮点数的二进制存储格式

   - $(20.59375)_{10} = (10100.10011)_2 ＝ 1.010010011 × 2^4$
   - 所以 $S=0;\; E = e+127=4+127=131 = 10000011;\; M=010010011$
   - 32 位浮点数存储格式为 $0\textcolor{#ee0000}{100\ 0001\ 1}010\ 0100\ 1100\ 0000\ 0000\ 0000 = (41A4C000)_{16}$

#### 四. 浮点数的表示范围

1. 浮点数的表示范围
   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230305193113767.png" alt="image-20230305193113767" style="zoom:50%;" />

   - 数据下溢时，浮点数值趋于 0 ，计算机将其视为机器 0 处理；数据上溢时，计算机将其视为无穷大

2. IEEE754 标准 浮点数表示范围

   - 32 位表示法: ![image-20230305121318625](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230305121318625.png)

     $2^{-126} \leq |x| \leq (2-2^{-23})\times 2^{127}$

   - 64 位表示法: ![image-20230305121323933](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230305121323933.png)

     $2^{-1022} \leq |x| \leq (2-2^{-52})\times 2^{1023}$

> 浮点数格式小结（以 32 位为例） ![image-20230305121318625](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230305121318625.png)
>
> - 非规格化：无特殊要求
> - 规格化的: $对尾数有要求\begin{cases}符号位:0/1& 1xxxxxx \\补码表示时\begin{cases}符号位\textcolor{#ee0000}{0} & \textcolor{#ee0000}1xxxxxx\\ 符号位\textcolor{#ee0000}1 & \textcolor{#ee0000}0xxxxxx\end{cases}\end{cases} $
> - 计算对应真值: $x = (-1)^s\times (\textcolor{#ee0000}{0.}M)\times 2^\textcolor{#ee0000}{E-128};\quad e:-128\sim+127$
>
> ---
>
> - IEEE754:
>   - 尾数**只有原码**; 尾数域前**隐含 1**;
>   - 阶码为**隐含移码, 不能全 0/全 1**
> - 计算对应真值: $x = (-1)^s\times (\textcolor{#ee0000}{1.}M)\times 2^\textcolor{#ee0000}{E-127};\quad e:-126\sim+127$

> 例 : 假设由 S E M 三个域组成的一个 32 位二进制字所表示的非零规格化浮点数ｘ真值表示为$x = (-1)^s\times (0.M)\times 2^{E-128}$
>
> 问：它所表示的规格化的最大正数、最小正数、最大负数、最小负数是多少？

- 阶码用移码表示，8 位；尾数用原码, 23 位

1. 最大正数

   - **阶码**为最大正数， 尾数为最大正数

   - 存储码：$0 \textcolor{#ee0000}{111\ 1111\ 1}111\ 1111\ 1111\ 1111\ 1111\ 1111$
   - $x = [1+(1-2^{-23})]\times 2^{127}$

2. 最小正数

   - **阶码**为最小负数（绝对值最大） , 尾数为最小正数
   - $0 \textcolor{#ee0000}{000\ 0000\ 0}000\ 0000\ 0000\ 0000\ 0000\ 0000$
   - $x = 1.0\times 2^{-128}$
   - <font color='orange'>不是 IEEE754, 阶码没有特殊要求</font>

3. 最小负数 (绝对值最大)

   - **阶码**为最大正数， 尾数为最小负数（绝对值最大）
   - $1 \textcolor{#ee0000}{111\ 1111\ 1}111\ 1111\ 1111\ 1111\ 1111\ 1111$
   - $x = -[1+(1-2^{-23})]\times 2^{127}$

4. 最大复数 (绝对值最小)

   - **阶码**为最小负数（绝对值最大） , 尾数为最大负数(绝对值最小)
   - $1 \textcolor{#ee0000}{000\ 0000\ 0}000\ 0000\ 0000\ 0000\ 0000\ 0000$
   - $x = -1.0\times 2^{-128}$

## 2.2 定点加法、减法运算

### 2.2.1 补码加法

1. 补码加法规则 : 两个相加的数无论正负，其和的补码等于两数补码之和：$[X+Y]_补 = [X]_补+[Y]_补$

2. > 例 : 设 X=+1001 Y=+0101 ，用补码求 Z=X+Y

   - $[X]_补 = 01001;\quad [Y]_补 = 00101$
   - $[X+Y]_补 = [X]_补+[Y]_补 = 01001+00101=01110$
   - $X+Y=01110$

3. > 例 : 设 X=0.1001 Y=-0.0101 ，用补码求 Z=X+Y

   - $[X]_补 = 0.1001;\quad [Y]_补 = 1.0101$
   - $[X+Y]_补 = [X]_补+[Y]_补 = 0.1001+1.0101=0.0100$
   - $X+Y=+0.01$

### 2.2.2 补码减法

1. 补码减法规则 : 两个相减的数无论正负$[X-Y]_补 = [X]_补+[-Y]_补$

   - $[-Y]_补$为$[Y]_补$的机器负数, 转换方法: ==将连同符号位一起变反, 末位加一==

2. > 例 : 设 X=+1001 Y=+0101 ，求 x-y

   - $[X]_补 = 01001;\quad [Y]_补 = 00101;\quad [-Y]_补 = 11010$
   - $[X+Y]_补 = [X]_补+[Y]_补 = 01001+11010=\textcolor{#ee0000}{1}00111$
   - $X+Y=+0111$

> 补码加减运算规则小结
>
> - 参加运算的操作数用补码表示。
> - 符号位参加运算。
> - 若指令操作码为加，则两数直接相加；若操作码为减，则将减数连同符号位一起变反加 1 后再与被减数相加。
> - 运算结果用补码表示。
>
> 补码使得加减可以统一处理, 只需要加上一个取反操作

### 2.2.3 溢出判断

1. 基本规律： 两个异号数相加或两个同号数相减不会发生溢出；只有 两个同号数相加 或 两个异号数相减 才可能 发生溢出
   - 正溢 ：运算结果为正 且 大于所能表示的最大正数；
   - 负溢 ：运算结果为负 且 小于所能表示的最小负数；
2. 溢出判断方法:
   - 采用一个符号位来判断 (最高有效位判断法)
   - 采用双符号位法(变形补码法)

#### 一. 单符号位（最高有效位）判断法

两个补码数相加、减时，若最高数值位向符号位送的进位值与符号位送向更高位进位不相同，则运算结果溢出

溢出的逻辑表达式; $V = C_S\oplus C_1$ ; 若 V=0, 表示无溢出; V=1, 表示有溢出

#### 二. 双符号位法(变形补码法, 模 4 补码法)

- <font color='#66ccff'>变形补码</font> : $[x]_补 = 2^{n+2}+x$

- 变形补码的符号用两位($S_{S1}S_{S2}$)来表示; 两个符号位一起参与运算; 两个符号相同时, 未溢出; 两个符号位不相同时, 溢出

  - $S_{S1}S_{S2} = 00$ : 结果为正数, 无溢出
  - $S_{S1}S_{S2} = 01$ : 结果为正溢出
  - $S_{S1}S_{S2} = 10$ : 结果为负溢出
  - $S_{S1}S_{S2} = 11$ : 结果为正数, 无溢出
  - 最高位表示正确的符号

- > 【例】ｘ＝＋ 01100, ｙ＝＋ 01000, 求ｘ＋ｙ

  - $[ｘ]_补＝ \textcolor{#ee0000}{00}1100, [ｙ]_补＝ \textcolor{#ee0000}{00} 1000 ;\quad[x]_补+[y]_补 = \textcolor{#ee0000}{01} 0100$
  - 两个符号位不一致, 结果溢出

- > 【例】ｘ＝－0.1100, ｙ＝ 0.1000, 求ｘ＋ｙ

  - $[ｘ]_补＝ \textcolor{#ee0000}{11}.0100, [ｙ]_补＝ \textcolor{#ee0000}{11}.1000 ;\quad[x]_补+[y]_补 = \textcolor{#ee0000}{10}.1100$
  - 两个符号位不一致, 结果溢出

### 2.2.4 基本的二进制加减法器

1. 一位全加器 $\begin{cases} 
   S_i = A_i\oplus B_i\oplus C_{i_1} \\
   C_i = A_i B_i + (A_i\oplus B_i) C_{i-1}
   \end{cases}$ <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230306111902802.png" alt="image-20230306111902802" style="zoom:33%;" />

2. 时延 <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230306112157689.png" alt="image-20230306112157689" style="zoom:50%;" />

   - 对于 $A_i, B_i, C_i三个输入$

     $S_i的时延为: 3T\times 2 = 6T$

     $C_{i+1}的时延为: 3T+2T = 5T$

   - 简单门电路(与或非)时延 :1T; 复杂门电路时延 : 3T

3. n 位加法器设计

   - n 位加法器可由 多个 1 位加法器级联 实现（行波进位加法器）
   - 补码减法器可由加法器实现。 方式控制线 M, 0 表示加，1 表示减 (将连同符号位一起变反, 末位加一)
   - 优点: 节省器件, 成本低; 缺点: 有延时传递, 运算慢

4. > <a name="串行n位加法器的时延分析">拓展: 整个 n 位加法器的时延分析</a>
   >
   > - $产生各个FA的求和项时延: 3T(相对于A_i, B_i输入)$
   > - $C_1的时延: 5T(相对于FA的三个输入)$
   > - $C_n的时延 : 2T\times (n-1) = 2(n-1)T; (相对于C_1输入)$
   > - $V(溢出)的时延: 3T(相对于C_n输入)$
   >
   > <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230306112641271.png" alt="image-20230306112641271" style="zoom:50%;" />

## 2.3 定点乘法运算

### 2.3.1 原码乘法

1. 规则: 符号与数值分开计算
   - 乘积的数值部分是两个正数相乘之积。
   - 乘积符号的运算法则是：同号相乘为正 异号相乘为负。 可由符号位异或实现。

> 引【例】 ｘ=1101, ｙ=1011. 求 x\*y
>
> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230306113207096.png" alt="image-20230306113207096" style="zoom:33%;" /> 串行实现, 乘法比较慢, 如何进行改进

#### 一. 不带符号的阵列乘法器设计

1. 设有两个不带符号的二进制整数 $A = a_{m-1}...a_1a_0;\quad B=b_{n-1}…b_1b_0$

   数值部分为 a 和 b, 即$a = \sum^{m-1}_{i=0}a_i2^i;\quad b = \sum^{n-1}_{j=0}b_j2^j$

   则 A 与 B 相乘,产生 m ＋ n 位乘积 P：$P＝p_{m+n-1}…p_1p_0$

   $P = ab = (\sum^{m-1}_{i=0}a_i2^i) \cdot (\sum^{n-1}_{j=0}b_j2^j) = \sum^{m-1}_{i=0} \sum^{n-1}_{j=0}(a_ib_j)2^{i+j} = \sum^{m+n-1}_{k=0}p_k2^k$

2. 【例】 5\*5 阵列

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230306193514350.png" alt="image-20230306193514350" style="zoom: 33%;" />

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230306193558696.png" alt="image-20230306193558696" style="zoom:33%;" />

3. m× n 位不带符号的阵列乘法器逻辑框图

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230308162203679.png" alt="image-20230308162203679" style="zoom:50%;" />

   n\*n 的乘法计算，需要 <font color='#66ccff'>n\*(n-1) </font>个加法器。最慢的是 P8 全加器

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230308162235924.png" alt="image-20230308162235924" style="zoom:50%;" />

4. m×n 的乘法计算 需要用到==m×n== 个与门<font color='orange'>(获得初步结果)</font> ==m×(n-1)== 个加法器

   - > 扩展 n 位不带符号乘法器的时延分析

     1. 由$n^2$个与门, 同时产生各个 FA 的求和项$a_ib_j$的时延: `T`
     2. 垂直方向, 每经过一个 FA 有 6T, 到达倒 2 层的输入: `6T*(n-2)`
     3. 斜线方向产生进位输出, 到达最后一层的输入: `5T`
     4. 最后一层水平方向进位传递, 到达最后一个 FA 输入: `2T*(n-2)`
     5. 产生积的最高位求和结果: `3T`

     - 整个乘法器的时延 : `(8n-7)T`

#### 二. 带符号的阵列乘法器设计

1. **符号与数值分开处理**, 符号采用异或电路, 数值采用无符号阵列乘法器

   - 原码数据可以直接运算

   - 若输入为补码数据, 转换为原码计算

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230309234113094.png" alt="image-20230309234113094" style="zoom:50%;" />

2. 对 2 求补器的设计（实现原、补转换）

   - 采用**按位扫描技术**来执行求补操作；(从右往左看, 第一位的“1”之后的数据位取反, 符号位不变)
   - E 为控制信号线，可由数据 a 的符号位来控制；
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230310001808963.png" alt="image-20230310001808963" style="zoom: 50%;" />

3. 带符号的阵列乘法器设计

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230310143336273.png" alt="image-20230310143336273" style="zoom:50%;" />

   1. 输入数据用补码表示
   2. 单独计算最终符号
   3. 进行不带符号的原码乘法
   4. 将计算结果结合最终符号位，得到算后求补输出
   5. 计算算前求补器输出
   6. 将算后求补输出结合符号位转为真值

4. > 例 : 设ｘ=+15 ｙ=-13 ，用带求补器的补码阵列乘法器求出积 ｘ · ｙ

   - 设最高位为符号位，输入数据用 5 位补码表示：
     $[x]_补= 01111;\quad [y]_补 =10011$

   - 符号位单独运算：$ x_f\oplus y_F = 0\oplus 1=1$

   - 算前求补器 输出 $|x|=1111,|y|=1101$

   - 乘法阵列输出 $|x| × |y|=1100\ 0011$

     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230310143748596.png" alt="image-20230310143748596" style="zoom: 50%;" />

   - 乘积符号位为 1(负数)，则算后求补器输出为$0011\ 1101$

   - 所以，$[x × y]_补 =1 0011\ 1101;\quad x×y =(-195)_{10}$

   - 十进制数验证： $15 × 13 = (-195)_{10}$

## 2.4 定点除法运算

### 2.4.1 原码除法

1. 规则:符号与数值分开计算

   - 商的符号：同号为正, 异号相除为负。可由 $异或\oplus $ 实现。
   - 商的数值部分由两数的**绝对值**相除获得。 可看做是两个正数相除

2. > 引例 : ｘ = 0.1001, ｙ= 0.1011. 求 x ÷ y

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230310210457694.png" alt="image-20230310210457694" style="zoom:50%;" />
   - 被减数-除数不够减时, 该位商为 0, 不进行减法
   - 每一次除数右移
   - 当商的位数和除数相等时, 结束运算

### 2.4.2 除法器的设计

1. 恢复余数除法器
   - 通过减法依次比较被除数和除数，判定商。
   - 若不够减，则通过回加余数恢复 A
   - 缺点：控制复杂 (对于 A<0 的情况要多加一步, 无法对称)
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311103434801.png" alt="image-20230311103434801" style="zoom:50%;" />

> 除法运算要求：
>
> 1. 确保参与运算的均是 **纯小数**且 **被除数小于除数**
> 2. 被除数数值位 扩充为**除数数值位 2 倍**

2. <font color='#66ccff'>不恢复余数</font>除法器

   - 通过减法依次比较被除数和除数，判定商。
   - 若不够减，不恢复余数，而**根据余数的符号决定下一步操作**
   - 也称为<font color='#66ccff'>加减交替法</font>
   - 最后一步的操作特殊处理，若商为 0 要恢复余数
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311103806734.png" alt="image-20230311103806734" style="zoom:50%;" />

3. > ｘ = 0.101001, y = 0.111, 求 q =ｘ ÷ ｙ

   - $[x]_补 = 0.101001$
     $[y]_补=0.111;\ [-y]_ 补 = 1.001$
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311104233503.png" alt="image-20230311104233503" style="zoom:50%;" />
   - 每一轮余数的符号位进位, 即为商对应位的数值

4. 不恢复余数阵列除法器核心部件——可控加法/减法(CAS)

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311104419744.png" alt="image-20230311104419744" style="zoom:50%;" />
   - 共有四个输入和四个输出。
     其中 P=0 ，做加法 P=1，做减法
   - 考虑最大的信号时延, 则对于$C_i$的输入$C_{i+1}$的时延为 3T

5. 4 位不恢复余数阵列除法器逻辑原理图

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311105659378.png" alt="image-20230311105659378" style="zoom:50%;" />

   - $x=0.x_6 x_5 x_4 x_3 x_2 x_1$
   - $y=0.y_3 y_2 y_1$
   - $q=0.q_3 q_2 q_1$
   - $r=0.00r_6 r_5 r_4 r_3$

6. 注意点

   - 被除数（数值部分，即尾数）长度=2 \* 除数长度
   - 送入不恢复余数阵列除法器计算时， 必有$被除数<除数$ 。若原始数据不满足，则通过**比例因子**进行处理。
   - 2n 位除以 n 位的不恢复余数阵列除法器，含有$ (n+1)^2$个 CAS 单元。考虑最大信号延迟，除法执行时间为：$3*(n+1)^2 T$

## 2.5 定点运算器的组成

### 2.5.1 运算器的功能

1. 完成对二进制代码的 定点 算术和逻辑运算。
   - 算术运算：加、减、乘、除
   - 逻辑运算：逻辑非、逻辑加、逻辑乘、逻辑异。
2. 根据运算结果给出状态：有无溢出、有无进位、结果是否为零等。

### 2.5.2 算数逻辑运算单元 (ALU)

#### 一. ALU 结构

1. 核心部件: 1 位<font color='#66ccff'>全加器</font>
2. n 位全加器连同进位信号传送逻辑，可构成一个 n 位加法器。
3. 以加法器为核心，利用<font color='#66ccff'>函数发生器</font>对输入信号进行逻辑选择，则扩展为具有多种算术和逻辑运算功能的 ALU
   - ALU 的逻辑结构原理图 :
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311112128973.png" alt="image-20230311112128973" style="zoom:50%;" />

#### 二. n 位加法器的设计

1. 串行进位

   - 优点 : 设计简单, 成本低 <font color='orange'>(结构简单, 元器件用的少, 便宜)</font>
   - 缺点 : 速度慢, 瓶颈在[进位传递](#串行n位加法器的时延分析) (进位链)
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311113156294.png" alt="image-20230311113156294" style="zoom:50%;" />

2. 改进方法

   - 设相加的两个 n 位操作数为: $A = A_{n-1}A_{n-2}...A_i...A_0;\quad B = B_{n-1}B_{n-2}...B_i...B_0$

   - 进位为：$C_{i+1} = A_i B_i + (A_i\oplus B_i)C_i$

   - 设: $\begin{cases}G_i = A_i B_i&\textcolor{#66ccff}{进位发生输出信号}\\ P_i = A_i\oplus B_i &\textcolor{#66ccff}{进位传送输出信号}\end{cases}$

     则 $C_{i+1} = G_i + P_i C_i; \quad P_i、G_i和C_i$无关

   - **提高运算的速度，关键在于如何加快进位的传递**
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311114355039.png" alt="image-20230311114355039" style="zoom:50%;" />

3. 并行进位（先行进位、同时进位）

   - $C_1= G_0+P_0C_0$
     $C_2= G_1+P_1G_0+P_1P_0C0$
     $C_3= G_2+P_2G_1+P_2P_1G_0+P_2P_1P_0C0$
     $C_4= G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1G_0+P_3P_2P_1P_0C_0$

   - 4 位进位链线路图（先行进位芯片 74182 逻辑图）

     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311115737202.png" alt="image-20230311115737202" style="zoom: 50%;" />

4. 4 位并行进位并行加法器设计

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311115830626.png" alt="image-20230311115830626" style="zoom:50%;" />

5. 16 位并行进位并行加法器设计

   - 组内并行、**组间串行**的进位链
     ![image-20230311120027954](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311120027954.png)

   - 组内并行、**组间并行**的进位链

     $C_4 = G_3 +P_3 C_3 = G_3 +P_3 G_2 +P_3 P_2 G_1 +P_3 P_2 P_1 G_0 + P_3 P_2 P_1 P_0 C_0=G'_0 +P'_0C_0$

   - $G'_0 : 成租进位发生传输信号;\quad P'_0: 成租进位传送输出信号$

   - ![image-20230311120704361](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311120704361.png)

#### 三. 多种算数逻辑的实现

1. 控制参数$S_0、S_1、S_2、S_3$控制输入$A_i、B_i$进行不同的逻辑组合，生成$X_i、Y_i$的函数

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311121145682.png" alt="image-20230311121145682" style="zoom: 33%;" /> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311121203133.png" alt="image-20230311121203133" style="zoom: 50%;" />

2. 74181 ALU 逻辑电路图（ 4 位，正逻辑）
   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311121407340.png" alt="image-20230311121407340" style="zoom:50%;" />

   - 控制端 M ：选择运算器的操作类型

     - 0 ，算术运算

     - 1 ，逻辑运算

     - > 算术运算与逻辑运算的差别：==是否考虑进位==
       >
       > - 算术运算： 每一位运算都需要考虑前一位的进位状态；
       > - 逻辑运算：每一位运算都是独立进行的，不考虑进位；

   - 两种工作方式：正逻辑操作、负逻辑操作
     - 正逻辑<font color='orange'>(高电平有效)</font>： 1 表示高电平； 0 表示低电平；
     - 负逻辑<font color='orange'>(低电平有效)</font>： 0 表示高电平； 1 表示低电平；
   - 共能进行 16 种算术运算和 16 种逻辑运算

3. 运用 4 片 `74181`(4 位)和一片 `74182` 构成 16 位组内、组间先行进位运算器设计

   ![image-20230311121752480](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311121752480.png)

### 2.5.3 定点运算器的基本结构

- 运算器包括： ALU 、阵列乘除器、寄存器、数据总线等。

- 运算器的设计主要围绕 ALU 和寄存器同数据总线之间如何传送操作数和运算结果进行

  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311121850932.png" alt="image-20230311121850932" style="zoom:50%;" />

#### 一. 内部总线

1. 总线：是连接计算机系统各个部件和装置的线路，是 **多个** 信息源传送信息到 **多个** 目的地的数据通路。
2. 总线的分类
   - 根据总线所在位置分：
     - 内部总线 ：指 CPU 内各部件的连线
     - 外部总线 ：也称系统总线，是 CPU 与存储器、I/O 系统之间的连线。
   - 按总线的逻辑结构分：
     - 单向传送总线 ：指信息只能向一个方向传送
     - 双向传送总线 ：指信息可以分两个方向传送。
     - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311122152107.png" alt="image-20230311122152107" style="zoom:50%;" />

#### 二. 定点运算器的基本结构

1. 单总线结构运算器：

   - 优点 ：设计、控制简单
   - 缺点 ：速度慢

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311134438709.png" alt="image-20230311134438709" style="zoom:33%;" />

2. 双总线结构运算器：

   - 缺点 ：设计、控制较复杂
   - 优点 ：速度快
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311134505494.png" alt="image-20230311134505494" style="zoom:50%;" />

3. 三总线结构运算器：

   - 缺点 ：设计、控制复杂
   - 优点 ：速度最快。
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230311134531225.png" alt="image-20230311134531225" style="zoom: 33%;" />

## 2.6 浮点运算方法和浮点运算器

### 2.6.1 浮点加减运算

1. 对阶：使得小数部分可以按位权值按位相加

   - > $2^{10}\times(0.11000)+2^8\times0.00110$

     - 大阶对小阶 $2^{10} *(0.11000)→ 2^8*(11.000)$ <font color='orange'>高位超出浮点表示范围</font>
       11\.000+0.00110
     - 小阶对大阶 $2^8*(0.00110)→2^{10}*0.00001$

       0.00001+0.11000 = 0.11001

   - 对阶应该**小阶对大阶**, 尾数右移, 以避免浮点数的最高位数据丢失

#### 浮点数加减运算规则

- (以$X = M_X*2^{E_x}; Y=M_Y*2^{E_Y}$为例)

1. 0 操作数的检查
2. 比较阶码大小, 完成对阶
   - 由减法实现
   - 提升小的阶码(小阶对大阶), 尾数右移变小
3. 尾数进行加/减运算
   - 采用补码运算, 变减为加
   - 若有溢出, 先原样保留
4. 结果规格化 (补码为： 0.1xxx 或 1.0xxx)
   - 尾数计算结果未溢出、规格化
     无需处理
   - 尾数计算结果未溢出，但非规格化
     **尾数左移**以满足规格化要求， **阶码做减** 。
   - 尾数计算结果溢出
     **尾数右移**至不溢出、满足规格化要求， **阶码做加**
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230331165457645.png" alt="image-20230331165457645" style="zoom:50%;" /> 右规的结果要先保留
5. 舍入处理。
   - 0 舍 1 入法 : 若移出位为 1，则尾数加 1
   - 末位恒 1 法 : 直接将结果的最低位置 1
   - IEEE754 标准：就近舍入、朝 0 舍入、朝+∞ 舍入、 朝-∞ 舍入
6. 溢出处理
   - 阶码上溢： 超出最大正数，认为为+∞ 或-∞ 数。
   - 阶码下溢： 超出最小负数，认为为数据 0
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230331165947626.png" alt="image-20230331165947626" style="zoom:50%;" />
   - 尾数溢出并不是真正的溢出, 阶码溢出才是

> 设 $x=2^{010} × 0.11011011,y=2^{100} × (-0.10101100)$, 求 ｘ+ｙ
>
> 设阶码和尾数均用补码表示, 阶码采用双符号位, 字长 5 位; 尾数用单符号位, 字长 9 位

- $[x]_浮=00\ 010, 0.11011011; [y]_浮 = 00\ 100, 1.01010100$

1. 对阶
   - $\Delta E = E_x-E_y=[E_x]_补+[-E_y]_补=00010+11100=11\ 110$
   - $\Delta E=-2$, x 的阶码小, M~x~右移两位, E~x~加 2
   - $[x]_浮(对阶后)=00\ 100,0.00110110\textcolor{#ee0000}{(11)}$
2. 尾数求和
   - $0.00110110(11)+1.01010100=1.1001010(11)$
3. 规格化处理
   - 尾数非规格化 ，左规处理后 $1.00010101(10)$ 阶码为 $00\ 011$ 。
4. 舍入处理
   - 采用 0 舍 1 入法处理 1.00010110
5. 溢出判断
   - 阶码符号位为 00, 不溢出。
   - 结果为 ：$x+y=2^{011} × (-0.11101010)$

### 2.6.2 浮点乘除运算

1. 设两个浮点数： $X = M_x × 2^{E_x}$ 和 $Y = M_Y × 2^{E_Y}$

- 乘法： $X × Y=2^{E_x+E y} × (M_x ·M_y)$
- 除法：$ X ÷ Y=2^{E_x-E_y} × (M_x ÷ M_y)$

2. 浮点数乘除运算的步骤

   - 0 操作数检查；

   - 阶码加/减操作；

   - 尾数乘/除操作；

   - 结果规格化、舍入和溢出处理；

3. 移码运算规则：

   - $[x+y]_移 =[x]_移 +[y]_补\quad (mod\ 2^{n+1})$
     $[x-y]_移=[x]_移[-y]_补$
   - 移码溢出判断规则：
     采用 **双符号位** 并规定移码的第二个符号位 即为**最高符号**
     - 位恒用 0 参加加减运算 阶码的最高符号位为 1 时产生溢出 。
     - 当两位符号位为 10 时表明**上溢** ; 为 11 时 表明**下溢**。
     - 当最高符号位为 0 时 表明没有溢出；两位符号位为 01 时 结果为正 ；为 00 时 结果为负

4. > 设有浮点数 $ｘ=2^{-5}*0.0110011$ $ｙ=2^3*(-0.1110010)$，阶码用 4 位移码表示, 尾数(含符号位) 用 8 位补码表示。
   >
   > 求$ [ｘ × ｙ]\_浮$。
   >
   > 要求用原码 完成尾数乘法运算; 运算结果尾数保留高 8 位(含符号位), 并用尾数低位字长值处理舍入操作。

   - $[Mx]_原=0.0110011, [My]_原 = 1.1110010,$
     $[Ex]_移=00\ 011,[Ey]_移 = 01\ 011, [ E ｙ]_ 补= 00\ 011$
     $[ｘ]_浮＝ 00\ 011, 0.0110011, [ｙ]_浮＝ 01\ 011, 1.0001110$

   1. 求阶码和
      $[E ｘ+E ｙ]_移=[E ｘ]_移+[Eｙ]_补＝00\ 011+00\ 011=00\ 110$
   2. 尾数相乘（用原码阵列乘法器）
      $[M ｘ]_原 × [M ｙ]_原＝[0.0110011] ×[1.1110010]=1.0101101,0110110$
   3. 规格化处理 : 非规格化数，尾数左移，阶码减
      乘积的尾数规格化后阶码变为 $00\ 101(-3)$,
      尾数变为$1.1011010,1101100$
   4. 舍入处理
      尾数为负数 取尾数高位字长，丢失最高位为 1 ，加入，故尾数为 1.1011011
   5. 结果为: $[x×y]_浮＝ 00\ 101,1.1011011$
      其真值为$x×y = 2^{-3} × (-0.1011011)$

### 2.6.3 浮点运算流水线

- 流水线工作原理： 计算机将输入的任务分割为一系列的子任务 使各子任务能在流水线的各个阶段 并发地 执行 。采用流水线处理提高计算机的性能的主要技术之一 。
- <font color='#66ccff'>线性流水线</font> ：若作业 T 被分成 k 个子任务，即 $T\{T_1,T_2,··· ,T_k \}$，各个子任务之间有一定的优先关系若 i < 则必须在 $T_i$ 完成以后 $T_j$ 才能开始工作。具有这种线性优先关系的流水线称为线性流水线。
- $S ：过程段;  L ：缓冲寄存器$
  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230403120207618.png" alt="image-20230403120207618" style="zoom:50%;" />

#### 主要参数

- 时钟周期 $τ=max\{ τ_i\}+τ_l=τ_m+τ_l$
- 流水线处理频率 $f=1/ τ $
- 线性流水线的<font color='#66ccff'>加速比 </font>:
  - 线性流水线中一个具有 k 级过程段的流水线处理 n 个任务需要的时钟周期数为： $T_k = k +(n-1)$
    - k: k 个周期, 用于启动流水线; n-1: 剩下的 n-1 个任务, 每个耗时 1 个周期
  - 非流水线处理 n 个任务的时间为： $T_k = n·k$
  - 则==加速比== 为：$C_k = \frac{T_1}{T_k} = \frac{n\cdot k}{k+(n-1)}; 当 n>>k 时， C_k=k$
  - 浮点数运算器结构常采用流水线方式, 提高效率
- 如浮点加减法可分成 **0 操作数检查、对阶、尾数操作、格式化和舍入处理** 4 个子任务完成

- 注意

  - 当流水线中各子段处理时间相同时, 有 <font size="5">$C_k = \frac{T_1}{T_k} = \frac{n\cdot k}{k+(n-1)}$ </font>

  - 当流水线中个字段处理时间不同时, 加速比可以看做进入稳定工作状态后, 非流水线和流水线处理 1 个任务的时间比

    <font size="5">$C_k = \frac{\sum^k_{i=0}τ_i}{max\{τ_i\} + τ_l}$ </font>

- 例 : <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230403122113287.png" alt="image-20230403122113287" style="zoom:50%;" />

## 2.7 本章开头提出的问题回答

1. 在计算机中，为什么要采用二进制来表示数据？

   - 从可行性来说，采用二进制，只有 0 和 1 两个状态，能够表示 0、1 两种状态的电子器件很多，如开关的接通和断开、晶体管的导通和截止、磁元件的正负剩磁、电位电平的高与低等，都可表示 0、1 两个数码。使用二进制，电子器件具有实现的可行性。
   - 从运算的简易性来说，二进制数的运算法则少，运算简单，使计算机运算器的硬件结构大大简化(十进制的乘法九九口诀表有 55 条公式，而二进制乘法只有 4 条规则)从逻辑上来说，由于二进制 0 和 1 正好和逻辑代数的假( false)和真(true)相对应，有逻辑代数的理论基础，用二进制表示二值逻辑很自然。

2. 计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。

   - 计算机采用二进制来表示数据，在字长足够时，可以表示任何一个整数。而二进制表示小数时只能够用 1(2)的和的任意组合表示，即使字长很长，也不可能精确表示出所有小数，只能无限逼近。例如 0.1 就无法用二进制精确地表示。

3. 字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？

   - 字长相同时，浮点数取字长的一部分作为阶码，所以表示范围比定点数要大，而取一部分作为阶码也就代表着尾数部位的有效位数减少，而定点数字长的全部位都用来表示数值本身，精度要比同字长的浮点数更大。

4. 用移码表示浮点数的阶码有什么好处？
   - 移码的两个好处
     ① 浮点数进行加减运算时，时常要比较阶码的大小，相对于原码和补码，移码比较大小更方便。
     ② 检验移码的特殊值(0 和 max)时比较容易。
   - 阶码以移码编码时的特殊值如下。
     - **0**:表示指数为负无穷大，相当于分数分母无穷大，整个数无穷接近 0,在尾数也为 0 时可用来表示 0; 尾数不为零表示未正规化的数。
     - **max**:表示指数正无穷大，若尾数为 0,则表示浮点数超出表示范围（正负无穷大）；尾数不为 0,则表示浮点数运算错误

## 2.6 常见问题

1. 如何表示一个数值数据？计算机中的数値数据都是二进制数吗？

   - 在计算机内部，数值数据的表示方法有以下两大类。
     ① 直接用二进制数表示。分为无符号数和有符号数，有符号数又分为定点数表示和浮点数表示。无符号数用来表示无符号整数（如地址等信息）；定点数用来表示整数；浮点数用来表示实数。
     ② 二进制编码的十进制数，一般都采用 8421 码(也称 NBCD 码)来表示，用来表示整数。
   - 所以，计算机中的数值数据虽然都用二进制来编码表示，但不全是二进制数，也有用十进制数表示的。后面一章有关指令类型的内容中，就有对应的二进制加法指令和十进制加法指令。

2. 在高级语言编程中所定义的 unsigned/short/int/long/float/double 型数据是怎么表示的？什么称为无符号整数的“溢出”？

   - unsigned 型数据就是无符号整数，不考虑符号位。直接用全部二进制位对数值进行编码得到的就是无符号数，一般都用补码表示。
   - int 型数据就是定点整数，一般用补码表示。int 型数据的位数与运行平台和编译器有关，一般是 32 位或 16 位。例如，真值是-12 的 int 型整数，在机器内存储的机器数（假定用 32 位寄存器寄存）是`1111-1111-1111-1111-1111-1111-1111-0100`
   - long 型数据和 short 型数据也都是定点整数，只是位数不同，分别是长整型和短整型数，通常用补码表示。
   - float 型数据是用来表示实数的浮点数。现代计算机用 IEEE754 标准表示浮点数，其中 32 位单精度浮点数就是 float 型，64 位双精度浮点数就是 double 型。
   - 需要注意的是，C 语言中的 int 型和 unsigned 型变量的存储方式没有区别，都按照补码的形式存储，在不溢出范围内的加减法运算也是相同的，只是 int 型变量的最高位代表符号位，而 unsigned 型中的最高位表示数值位，两者在 C 语言中的区别体现在输出时到底是采用%d 还是采用%u。
   - 对于无符号定点整数来说，若寄存器位数不够，则计算机运算过程中一般保留低 n 位，舍弃高位。
     这样，会产生以下两种结果。
     ① 保留的低 n 位数不能正确表示运算结果。在这种情况下，意味着运算的结果超出了计算机所能表达的范围，有效数值进到了第 n+1 位，称此时发生了“溢出”现象
     ② 保留的低 n 位数能正确表达计算结果，即高位的舍去并不影响其运算结果

3. 如何判断一个浮点数是否是规格化数？

   - 为了使浮点数能尽量多地表示有效位数，一般要求运算结果用规格化数形式表示。(规格化浮点数的尾数小数点后的第一位一定是个非零数。
   - 因此，对于原码编码的尾数来说，只要看尾数的第一位是否为 1 就行：对于补码表示的尾数，只要看符号位和尾数最高位是否相反。
   - 需要注意的是，IEEE754 标准的浮点数尾数是用原码编码的。

4. 对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？

   - 不是，可表示的数据个数取决于编码所采用的位数。编码位数一定，编码出来的数据个数就是一定的。
   - m 位编码只能表示 2^m^个数，所以对于相同位数的定点数和浮点数来说，可表示的数据个数应该一样多 (有时可能由于一个值有两个或多个编码对应，编码个数会有少量差异)。

5. 浮点数如何进行舍入？

   - 舍入方法选择的原则是：
     ① 尽量使误差范围对称，使得平均误差为 0,即有舍有入，以防误差积累。
     ② 方法要简单，以加快速度。
   - IEEE754 有 4 种舍入方式。
     ①<font color='#66ccff'>就近舍入</font>：舍入为最近可表示的数，若结果值正好落在两个可表示数的中间，则一般选择舍入结果为偶数。
     ②<font color='#66ccff'>正向舍入</font>：朝+∞ 方向舍入，即取右边的那个数
     ③<font color='#66ccff'>负向舍入</font>：朝-∞ 方向舍入，即取左边的那个数。
     ④<font color='#66ccff'>截去</font>：朝 0 方向舍入，即取绝对值较小的那个数

6. 现代计算机中是否要考虑原码加减运算？如何实现?

   - 因为现代计算机中浮点数采用 IEEE754 标准，所以在进行两个浮点数的加减运算时，必须考虑原码的加减运算，因为 IEEE754 规定浮点数的尾数都用原码表示。
   - 原码的加减运算可以有以下两种实现方式
     - 转换为补码后，用补码加减法实现，结果再转换为原码。
     - 直接用原码进行加减运算，符号和数值部分分开进行（具体过程见原码加减运算部分）。

7. 长度为 n+1 的定点数，按照不同的编码方式，表示的数值范围是多少？ 各编码方式的数值范围见表 2.8 ![img](https://img-blog.csdnimg.cn/20210121105658823.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

8. 设阶码和尾数均用补码表示，阶码部分共 K+1 位(含 1 位阶符)，尾数部分共 n+1 位（含 1 位数符），则这样的浮点数的表示范围是多少？ 浮点数的表示范围见表 2.9。 ![img](https://img-blog.csdnimg.cn/20210121110204602.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210118103433182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

# 第三章 存储器

## 【复习提示】

本章是历年考査的重点，特别是有关 Cache 和存储器扩展的知识点容易出综合题。此外，存储器的分类与特点，存储器的扩展(芯片选择、连接方式、地址范围等)，低位交叉存储器，Cache 的相关计算与替换算法，虚拟存储器与快表也容易出选择题。读者应在掌握基本原理和理论的基础上，多结合习题进行练习复习，以加深和巩固。另外，读者还需掌握存在 Cache 和 TLB 的计算机中的地址翻译与 Cache 映射问题，该问题在《操作系统考研复习指导》中有详细说明。 本章有两个难点：一是 ache 映射规律、容量计算及替换特性；二是交又存储器访问时间和访问效率。二者都可与第 5 章的大题综合，或与第 6 章总线访问内存时间的计算问题综合。

在学习本章时，请读者思考以下问题：

- 1)存储器的层次结构主要体现在何处？为何要分这些层次？计算机如何管理这些层次？
- 2)存取周期和存取时间有何区别？
- 3)在虚拟存储器中，页面是设置得大一些好还是设置得小一些好？

请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。 ![img](https://img-blog.csdnimg.cn/2021011810360993.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

## 3.1 存储器概述

1. 存储器的作用
   - 存储 CPU 执行的指令和数据
   - 与输入输出设备直接交换数据；
   - 在多处理器系统中，存储共享数据。
2. 存储器的单位
   - <font color='#66ccff'>存储元（存储位）</font>: 保存一个二进制位
   - <font color='#66ccff'>存储单元</font>： 由若干个存储元组成；每个存储单元占用 1 个地址
     - 地址 : 按照编址方式分为 <font color='#66ccff'>字地址</font> 或 <font color='#66ccff'>字节地址</font>
   - <font color='#66ccff'>存储器</font>： 由许多存储单元组成
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230321205141422.png" alt="image-20230321205141422" style="zoom:33%;" />

### 3.1.1 存储器的分类

> <font color="blur" size="4">相联存储器</font>的基本原理是把存储单元所存内容的某一部分作为检索项（即关键字项）去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。所以它是 <font color="blur" size="4">按内容或地址进行寻址</font>的，价格较为昂贵。 <font color="blur" size="4">一般用来制作 TLB、相联 Cache 等</font>。

1. 按存储介质分类

   - 磁表面存储器（磁盘，磁带）

   - 磁芯存储器(已淘汰)

   - 半导体存储器（MOS 型存储器，双极存储器）

   - 光存储器（光盘）

   - > 用于存储的材料，必须具有区别分明的 2 个稳定状态

2. 按存取方式分类：

   - 随机存储器: 存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存取单元的物理位置无关
     - 半导体介质的存储器，均采用随机存取方式
   - 顺序存储器 ：只能按某种顺序来存取，存取时间和存储单元的物理位置有关。（如磁带）

3. 按存储器的内容可变性分
   - 只读存储器（ROM）：存储的内容只能读出而不能写入的半导体存储器。
     - 即使断电，内容也不会丢失
   - 随机读写存储器（RAM）：既能读出又能写入的半导体存储器
4. 按信息的易失性分

   - 非永久记忆的存储器 ：断电后信息即消失的存储器。(如 RAM)
   - 永久记忆性存储器 ：断电后仍能保存信息的存储器。(如 ROM)

5. 按在计算机中的**作用**对存储器分类：

   - <font color='#66ccff'>主存储器</font>,简称主存。==半导体存储器==

     - 能够被 CPU 直接访问，速度较快，用于保存系统当前运行所需的所有程序和数据
     - 可以和高速缓存器及辅助存储器交换数据

     - <font color='#66ccff'>辅助存储器</font>,简称辅存 ==磁盘, 光盘存储器==

       - 不能被 CPU 直接访问，速度较慢，用于保存系统中的所有的程序和数据

     - <font color='#66ccff'>高速缓冲存储器</font> (Cache) ==半导体存储器==

       - 能够被 CPU 直接访问，速度快，用于保存系统当前运行中频繁使用的程序和数据

     - <font color='#66ccff'>控制存储器</font> ==半导体存储器==
       - CPU 内部的存储单元。

### 3.1.2 存储器的技术指标

#### 存储器的性能指标

> 存储器的性能指标，有 3 个主要的性能指标，存储容量，单位成本和存储速度

- <font color='#66ccff'>存储容量</font>：指存储器所能容纳的存储元的总量。 ($存储容量 = 存储字数\times字长$ )

  - 常用容量单位： Byte 、 KB 、 MB 、 GB 、 TB

- <font color='#66ccff'>单位成本</font>：$每位价格=总成本/总容量 $
- 可靠性： 规定时间内存储器无故障读写的概率。

  - 常用平均无故障时间 MTBF 来衡量

- <font color='#66ccff'>存储速度</font>：$数据传输率=数据的宽度(即\ 每周期的信息量)/存储周期(即\ 周期时长) $

  - 存取时间(访问时间) $T_a$

    - 从**启动**一次存储器操作到**完成**该操作所经历的时间，
    - 以 ns 为单位, 存取时间分为**读出时间**和**写入时间**。

  - 存取周期 $T_m$

    - 它是指存储器进行一次完整的读写操作所需的全部时间，即**连续两次独立访问存储器操作**（读或写操作）之间所需的最小时间间隔。
    - 以 ns 为单位， $存取周期=存取时间+复原时间$

  - 主存带宽 $B_m$

    - 主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量
    - 单位为字/秒，字节/秒(B/s), 位/秒(b/s) <font color='orange'>1 字=2 字节=16 位</font>

  - 存取时间不等于存储周期，通常存储周期大于存取时间。因为任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。

> 【例】 设某存储系统的存取周期为 500ns ，每个存取周期可访问 16 位，则该存储器的带宽是多少？

- $存储带宽 = 每周期的信息量 / 周期时长= 16位 /(500\times10^{-9}) 秒= 3.2\times 10^7 位/秒= 32\times10^6 位 秒 = 32M位/秒$

#### 存储单元

**字**存储单元 : 存放一个字的存储单元，相应的单元地址叫**字地址**。
**字节**存储单元 : 存放一个字节的存储单元，相应的单元地址叫**字节地址**。

如果计算机可编址的最小单位是**字**存储单元，则称为**按字寻址**计算机。
如果计算机可编址的最小单位是**字节**存储单元，则称为**按字节寻址**计算机。

### 3.1.3 存储器的层次结构

| 名称           | 简称  | 用途                               | 特点                       |
| -------------- | ----- | ---------------------------------- | -------------------------- |
| 高速缓冲存储器 | Cache | 高速存取指令和数据                 | 存取速度快,但是存储容量小  |
| 主存储器       | 主存  | 存放计算机运行期间的大量程序和数据 | 存取速度较快, 存储容量适中 |
| 外存储器       | 外存  | 存放系统程序和大型数据文件及数据库 | 存储容量大, 位成本低       |

- 形成多级存储体系的依据——程序的局部性原理
  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/E$XEYZKX3YCW_IWD5QAZ%7BC9.png" alt="E$XEYZKX3YCW_IWD5QAZ{C9" style="zoom: 33%;" /> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230321231826102.png" alt="image-20230321231826102" style="zoom:50%;" />

- 系统对存储器的要求： 大容量、高速度、低成本
- 三级存储系统结构
  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230321231941135.png" alt="image-20230321231941135" style="zoom:50%;" />
- 存储器分级结构中应解决的问题：
  1. 当需从辅存中寻找指定内容调入主存时，如何准确定位？
     依靠相应的辅助软硬件。
  2. 当 CPU 访问 cache ，而待访问内容不在 cache 中时，应如何处理？
     从主存向 cache 中调入相应内容。
  3. 以上过程均由操作系统管理。

### 3.1.4 存储器的编址和端模式

1. 存储器的地址按**编址的最小单位**分为：
   - <font color='#66ccff'>字地址</font>——对应字存储单元
   - <font color='#66ccff'>字节地址</font>——对应字节存储单元
2. 存储字内部 多字节的排列方式 称为 <font color='#66ccff'>端模式</font>。
   - <font color='#66ccff'>大端存储</font> 高有效字节放在低地址端
   - <font color='#66ccff'>小端存储</font> 高有效字节放在高地址端
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230321233025815.png" alt="image-20230321233025815" style="zoom: 50%;" />

![img](https://img-blog.csdnimg.cn/20210118125753602.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210118112546228.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

## 3.2 主存储器

半导体存储器：常用 MOS 管构造

- 静态 MOS 存储器(**S**tatic **R**andom-**A**ccess **M**emory，<font color='#66ccff'>SRAM</font>) : 常用于 Cache
- 动态 MOS 存储器(**D**ynamic **R**andom-**A**ccess **M**emory，<font color='#66ccff'>DRAM</font>) : 常用于主存

共同点：

- 半导体介质；
- 根据地址可以访问任何存储单元且时间相同(随机存储)；
- 但属信息易失性。

### 3.2.1 SRAM 存储器

#### 一. 基本静态存储元

- SRAM 特点：
  - 采用**双稳态触发器**<font color='orange'>(RS 触发器)</font>来保存信息。
  - 集成度较低，功耗大、速度快。
- 基本存储元工作原理
  - 写入 ：选择信号为高(1)
    - 数据入为 0 ，写 0
    - 数据入为 1 ，写 1
  - 读出 ：从数据出读
  - 保持 ：选择线为地 0
  - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230321234302633.png" alt="image-20230321234302633" style="zoom:33%;" />

#### 二. SRAM 存储器的组成

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230321234431649.png" alt="image-20230321234431649" style="zoom:50%;" />

##### 存储体

1. 存储体 : 存储体由若干等长的存储单元组成；

   - 一个存储单元由若干个存储元(存 bit)构成，个数由存储器的字长决定

2. `存储单元的**地址** : 每一个存储单元具有一个唯一的地址, 可以存储 1 位/多位二进制数据(取决于存储单元中的存储元数量)

3. 存储容量 : 与地址、数据线个数有关

   - $芯片的存储容量=存储单元数 × 存储单元的位数=M × N = 2^Q × N$

     - Q: 芯片的地址线根数
     - M: 字数
     - N: 芯片的数据线根数 or 位数 (如按照字节编址, N=8 位)

   - > 例，芯片存储容量为 16B ，按字节编址，则表示为 $2^4 × 8 bit$
     >
     > - M=16; Q=4; N=8

> - 64 位/32 位计算机 指<font color='#66ccff'>CPU 数据总线宽度</font>, 决定 CPU 一次能处理多少位数据
> - 计算机地址长度(地址线根数) 指 CPU 地址总线宽度, 应该尽量和 CPU 数据总线宽度保持一致, 以提高性能
>   - $CPU有n位地址总线\stackrel{决定}\longrightarrow CPU能够寻址的内存地址数量为2^n$
>   - 如 32 位 CPU 地址总线, 最大内存为 2^32^B(4GB), 64 位最大内存为 2^64^B(16EB)

##### 地址译码电路

将用二进制代码表示的地址转换成输出端的高电位，用来驱动相应的读写电路，以便选择所要访问的存储单元。

1. 单译码
   - 被选存储单元由字线直接选定
   - 只使用于容量较小的存储芯片
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322093443669.png" alt="image-20230322093443669" style="zoom:50%;" />
2. 双译码
   - 二维译码结构，被选单元由 X 、 Y 两个方向的地址决定。
   - 简化芯片设计主要采用的译码结构
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322093612565.png" alt="image-20230322093612565" style="zoom:50%;" />

##### 片选和读写控制电路

> #表示非, 即低电平有效, 跟数电一样, 控制端多为低电平有效

- 片选端 `CS#` 或 `CE#`
  - 在地址选择时，首先要选片, 只有当片选信号有效时，此片所连的地址线才有效。
- 写 `WE#` 或读写 `R/W#`
  - 控制写/读操作。有效时，数据进入/输出芯片。
  - 该控制端对应系统的写 (读) 控制线。
- 输出允许 `OE#`
  - 控制读操作。有效时，允许芯片内数据输出。
  - 该控制端对应系统的读出允许控制线。

##### 总结 : SRAM 存储器连接 CPU 的外部信号线

1. 地址线 ：数量与 存储器的容量 有关
2. 数据线 ：数量与 存储器的字长 有关
3. 控制线 ：主要由 片选 与 读／写控制线组成
4. 片选信号 ：存储器工作的总控制信号产生电路。
5. 读/写控制信号： 决定对存储器进行何种操作。读和写不会同时发生

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322094125881.png" alt="image-20230322094125881" style="zoom:50%;" />

> 例： 32Kx8 位存储器芯片结构

- 芯片内构造： 由存储阵列、译码电路和输入 输出缓冲和控制电路组成。
- 外部引脚: 地址线; 15 ；数据线: 8; 片选: 1; 读写: 1，读使能 1

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322094344102.png" alt="image-20230322094344102" style="zoom:50%;" /> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322094401067.png" alt="image-20230322094401067" style="zoom:50%;" />

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322094456814.png" alt="image-20230322094456814" style="zoom:50%;" />

#### 三. SRAM 的读写周期

1. 读周期

   - 读周期操作过程

     1. CPU 发出有效的地址信号^①^
     2. 译码电路延迟产生有效的片选信号($\overline{CS}$)^②^
     3. 在读信号($\overline{OE}$)控制下，从存储单元中读出数据^③^
     4. 各控制信号撤销（地址信号稍晚），数据维持一段时间^④^

     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322124812866.png" alt="image-20230322124812866" style="zoom:50%;" />

   - <font color='#66ccff'>读出时间</font>： 从给出有效地址到外部数据总线上稳定地出现所读出的数据信息所经历的时间。

   - <font color='#66ccff'>读周期时间</font>： 存储器进行两次连续的读/写操作所必须的间隔时间； ==大于读出时间==

2. 写周期

   - 写周期操作过程 CPU

     1. 发出有效的地址信号 ，并提供所要写入的数据
     2. 译码电路延迟产生有效的片选信号($\overline{CS}$)
     3. 在写信号($\overline{WE}, 低电平有效$)控制下，将数据写入存储单元中
     4. 各控制信号撤销（地址信号稍晚），数据维持一段时间

     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322125334953.png" alt="image-20230322125334953" style="zoom:50%;" />

   - <font color='#66ccff'>写周期时间</font> : 指存储片进行两次连续写操作时所必须间隔的时间。
     - 一般与读周期时间相当。

3. 一般令读周期时间与写周期时间相当，称为<font color='#66ccff'>存取周期</font>

### 3.2.2 DRAM 存储器

#### 一. 基本存储元

- 由 **MOS 晶体管**和**电容**组成的记忆电路
  - 电容上的电量来表现存储的信息: 充电 1 ，放电 0
  - MOS 管作为开关使用
- 存储元工作原理
  - 写入 : 字控制线 =1: D=0 ，写 0; D=1 ，写 1
  - 读出 : 字控制线 =1: 可再生读出
  - 信息暂存 : 字控制线=0
- DRAM 的基本特点：
  - 利用 记忆电容 来保存信息；
  - 需要定时刷新 (电容会衰减)
  - 集成度高 ，功耗低。

#### 二. DRAM 逻辑结构

> DRAM 芯片容量比 SRAM 大 → 需要更多的地址位数 → 地址分为两次传入

- 内部基本组成： 存储阵列、译码电路、输入输出控制电路、 刷新控制电路

- 外部引脚： 地址线、数据线、控制线

  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322125915256.png" alt="image-20230322125915256" style="zoom: 67%;" /> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322125939842.png" alt="image-20230322125939842" style="zoom: 67%;" />

- DRAM 的地址译码电路特点

  1. 采用 行、列二维译码 结构（行地址、列地址）

  2. 共用 一组 外部地址线**分时**传送行、列地址

     - > 相同容量时, DRAM 外部地址引脚为 SRAM 一半，存储芯片集成度高，体积小

     - 行地址锁存器、 RAS

     - 列地址锁存器、 CAS

  3. 刷新电路：用于存储元的信息刷新

     - 需定时进行刷新， 与正常读写穿插 进行
     - 刷新计数器（刷新地址）与行地址二选一送入行译码

#### 三. DRAM 的读写周期与刷新周期

1. 读周期

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322193158012.png" alt="image-20230322193158012" style="zoom:50%;" />

2. 写周期

   <img src="C:/Users/14258/AppData/Roaming/Typora/typora-user-images/image-20230322193246781.png" alt="image-20230322193246781" style="zoom:50%;" />

   - $\overline{CAS}$ 滞后于 $\overline{RAS}$ 的时间必须要超过规定值；

   - $\overline{CAS}$ 和 $\overline{RAS}$ 的正负电平的宽度应大于规定值；

##### DRAM 刷新

1. 存储元基本操作
   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322194235363.png" alt="image-20230322194235363" style="zoom:50%;" />
   - 写入： 字控制线 =1
   - 读出： 字控制线 =1 → 数据被破坏
   - 信息暂存 ：字控制线 =0 → **数据随时间丢失** → 刷新来解决
2. DRAM 刷新的基本原理

   - 采用 “**再生读出**” 方式实现刷新
   - 每个芯片**按行**进行**定时**刷新
     - 故**刷新计数器的长度** / 每轮刷新次数 与 **DRAM 的行数** 相同
   - <font color='#66ccff'>最大刷新周期</font> : 在此时间内必须对电容刷新进行 ，以保持记忆的正确数据。
     - 常见： 2ms 、 8ms 、 16ms 等。
   - <font color='#66ccff'>刷新周期</font>：刷新一行所用时间, 与读写周期大小相等

3. 刷新电路 : 用于存储元的信息刷新

   - 刷新计数器（刷新地址）与行地址二选一送入行译码
   - 需定时进行刷新

4. DRAM<font color='orange'>(定时)</font>刷新的方式

   1. <font color='#66ccff'>集中刷新</font>: 在最大刷新周期内， 利用一段**固定时间**, **集中**安排 DRAM 依次对所有行**刷新 1 次** ，在这段时间**停止**对存储器的读/写操作

      - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322195515909.png" alt="image-20230322195515909" style="zoom:50%;" />
      - $死区的时长= tc * 行数; tc:读写周期$
      - 存在死区时间 ，会影响 CPU 的访存 操作；该方法适用于 实时性要求不高 的场合

   2. 分散刷新： 在最大刷新周期内， 读写周期与刷新周期交替出现。

      - 将每个系统工作周期分为两部分，前半部分用于 DRAM 读 写，后半部分用于刷新存储器的一行
      - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322195717470.png" alt="image-20230322195717470" style="zoom:50%;" />
      - 系统存取时间延长一倍，导致系统变慢；适用于低速系统。

   3. 异步刷新： 各刷新周期分散、均匀地安排在最大刷新周期内，每行刷新 1 次

      - > 若芯片有 1024 行，最大刷新周期 8ms
        >
        > <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322200820368.png" alt="image-20230322200820368" style="zoom:50%;" />

      - $最大刷新间隔时间=最大刷新周期/行数$

      - 不会产生明显的读写停顿，且不会延长系统的存取周期；

        且保证了在最大刷新周期内，每行至少要被刷新 1 次。

5. > 某计算机中由 1 片 DRAM 芯片 16KB (128\*128)构成主存，读写周期为 0.5us ，最大刷新周期为 2ms
   >
   > - 分析分别采用三种刷新方式的情况
   > - 若该计算机每 1us 至少要读写一次， 试分析该 DRAM 芯片用何种刷新方式？

   1. 集中式刷新方式
      - 周期总数=2ms/0.5us=4000; 刷新周期数量：128
      - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322201053612.png" alt="image-20230322201053612" style="zoom:50%;" />
      - “死区”时间为 0.5 μs × 128 = 64μs
      - “死时间率”为 128/4000 × 100% = 3.2%
   2. 分散式刷新方式
      - 存取周期延长一倍，为 1μs; 前 0.5μs 用于读写，后 0.5μs 用于刷新一行
      - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322201756282.png" alt="image-20230322201756282" style="zoom:50%;" />
      - $存取周期t_C = 读写周期t_M + 刷新周期t_R$
      - 刷新周期为$1 μ s × 128 行 = 128μs$
   3. 异步刷新方式
      - 若每隔 2ms/128=15.6 μs 刷新一行
      - 每隔 15.6μs 产生一个刷新请求信号；
      - 每 15.6μs 内的访问周期数量$ =15.6/0.5=31.2 个 ≈31$
      - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322202031583.png" alt="image-20230322202031583" style="zoom:50%;" />

#### 四. 高性能 DRAM

- 目的：增强基本 DRAM 的功能。

1. FPM-DRAM : 快速页模式动态存储器
   - 利用程序的局部性原理, 1 页例连续的数据只需要改变**列地址**即可
   - ![image-20230403130325899](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230403130325899.png)
2. CDRAM ：带 cache 的动态存储器
   - 在 DRAM 基础上集成一个 小 **SRAM**, 使得局部连续数据可从 SRAM 读出 猝发式读取 以提高速度
   - ![image-20230403130419664](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230403130419664.png)
3. SDRAM : 同步型动态存储器
   - 在 DRAM 基础上增加一个时钟信号 使得对数据的读取与系统时钟同步
   - ![image-20230403130508521](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230403130508521.png)

## 3.3 存储容量的扩充

> 单个存储芯片的容量有限，实际存储器由多个芯片扩展而成；
>
> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230322202834758.png" alt="image-20230322202834758" style="zoom:50%;" />
>
> - SRAM、 DRAM 、 ROM 均可进行容量扩展

- 存储器（存储芯片）与 CPU 的连接
  - 数据、地址、控制三总线分别连接；
  - 多个存储芯片 ↔ CPU (不是一一对应连接)
- 关注 存储芯片与 CPU 的外部引脚
- 存储器容量扩充方式 : 位扩展、字扩展、字位扩展

### 3.3.1 位数(字长)扩展

> 问题： 给定的芯片字长位数较短，不满足设计要求的存储器字长，则需要多个芯片扩展位数。

1. 基本方法： 各芯片的地址线和控制线公用， 数据线单独分开 。

   - $所需芯片数d= 设计要求的存储器容量/已知芯片存储容量$

2. > 例：利用 1Mx4 位的 SRAM 芯片，设计一个存储容量为 1Mx8 位 SRAM 存储器。

   - 所需芯片数 d=2

     ![image-20230325130544272](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230325130544272.png)

### 3.3.2 字拓展法(存储容量拓展)

> 问题： 给定芯片的容量较小，不满足设计要求的总存储容量，则需要多个芯片扩充字数（容量）

1. 基本方法 ：芯片地址和数据线公用, $R/\overline{W}$公用，==片选== 通过高位地址译码控制

2. 基本步骤

   1. 计算所需芯片数： d= 设计要求的存储器容量/已知芯片存储容量
   2. 计算出系统存储容量所需地址数 A1 ，及芯片的地址数 A2 。 A1 A2 得出高位地址数。
   3. 将芯片按高低顺序编号，分配高位地址数值。
   4. 将高位地址译码后分别控制芯片的片选信号

3. > 例：用 16K × 8 的芯片构成 64K × 8 的存储器

   - 16K × 8 的存储芯片: 地址线 14 根，数据线 8 根，$\overline{CS} $，$\overline{WE}$
   - CPU 的引脚：地址线 16 根，数据线 8 根，$\overline{MERQ}$ ，$\overline{WE}$
   - CPU 的最高 2 位地址和 /MREQ 信号产生 4 个芯片的片选信号；
   - 4 个存储芯片构成存储器的地址分配：
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230325131509643.png" alt="image-20230325131509643" style="zoom:50%;" />
     - $3FFFH→(2+4*3)个'1'→2^{14}=2^4K=16K$

### 3.3.3 字位拓展法

- 字向和位向都扩充

- 基本步骤

  1. 计算出 字位扩展所需的存储芯片的数目
  2. 先进行**位扩展**，形成满足位要求的存储芯片组
  3. 再使用存储芯片组进行**字扩展**

  - 组内进行位扩展，组间进行字扩展

> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230325132114211.png" alt="image-20230325132114211" style="zoom:50%;" />

- <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230325132207297.png" alt="image-20230325132207297" style="zoom:50%;" />

- <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230325132255101.png" alt="image-20230325132255101" style="zoom:50%;" /> 
  - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230325132424076.png" alt="image-20230325132424076" style="zoom:50%;" />
- 注意 : 74138 为低电平有效 选中位结果为 0, 其余为 1; 片选同样为低电平有效, 当输入为 0 时选中, 为 1 时无效

### 3.3.2 只读存储器

![img](https://img-blog.csdnimg.cn/20210118123203340.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210118123813543.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/2021011812392214.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

## 3.4 只读和闪读存储器

### 3.4.1 只读存储器 ROM

1. 存储介质：半导体
2. 特点：非易失性，正常工作态下只能读，存储元是单管。
3. 分类：
   - 掩模只读存储器：内容出厂前已设定，芯片只能读。
   - 可编程只读存储器
     - 一次编程只读存储器：芯片有二种工作状态：写（一次）、读。
     - 多次编程只读存储器
       - EPROM ：芯片有三种工作状态：写（只写 0 ）、光擦除、读。
       - EEPROM ：芯片有３种工作状态：写（只写 0 ）、电擦除、读。有串、并两种芯片结构。

### 3.4.2 闪速存储器 flash

1. 存储介质：半导体
2. 特点：非易失性，保存数据更长久，功耗更低，数据传输率更高。
3. 芯片工作状态：写 ( 只写 0) 、电擦除、读。片内具有指令寄存器来进行电擦除和编程操作。

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230403130903724.png" alt="image-20230403130903724" style="zoom:67%;" />

## 3.5 并行存储器

> 由于 CPU 和主存储器速度不匹配，为了提高传输速率，采用并行技术
>
> - 空间并行技术 : 双端口 多端口存储器
> - 时间并行技术 : 多模交叉存储器

### 3.5.1 双端口存储器

1. 特点：一个存储器具有 **两组相互独立的读写控制线路**（地址线、数据线和控制线 ）。从而，两个端口可以进行并行的独立操作
2. 无冲突读写控制

   - 当两个端口的**地址不相同**时，在两 个端口上可同时进行读写操作，且不会发生冲突。
   - `R/W#` ：读写控制信号，高时为读，低时为写，且高 8 位和低 8 位分开控制。
   - `CE#`：端口片选信号，低有效。
   - `OE#`：输出控制信号（读控制），低有效。
   - <font color='orange'>显卡上的存储器一般都是双端口存储器</font>

3. 有冲突读写控制
   - 当两个端口同时存取存储器同一存储单元时，发生读写冲突，由判断逻辑电路作选择，使用 BUSY#控制读写优先顺序
   - `BUSY#` ：关闭端口信号，低电平有效，即**读写操作对 BUSY 变为低电平的端口不起作用**

### 3.5.2 多模块交叉存储器

> 存储器由若干个模块组成，有两种不同的编址（组织）方式
>
> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230406235623650.png" alt="image-20230406235623650" style="zoom: 50%;" />

- **程序局部性原理**：是指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域，具体来说，局部性通常有两种形式：时间局部性和空间局部性。
  - **时间局部性：**被引用过一次的存储器位置在未来会被多次引用（通常在循环中）。
  - **空间局部性：**如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。
    ![img](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/20210118153706155.png)

1. 顺序方式：

   - 顺序访问地址连续的存储单元时(**局部性原理**), 只能单个模块工作， 其他模块不工作（<font color='#66ccff'>串行工作</font>）
   - 某一模块出现故障时，其他模块可以照常工作；
   - 通过增添模块来扩充存储器容量比较方便。
   - 各模块串行工作，存储器的带宽受到了限制。
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230407000029938.png" alt="image-20230407000029938" style="zoom:50%;" />

2. 交叉方式：

   - 多体交叉存储器是指存储体内有多个容量相同的存储模块，而且各存储模块都有各自独立的地址寄存器、译码器和数据寄存器， 各模块可独立工作 。
   - 多个模块采用 **交叉编址** ，连续的地址被安排在不同的模块中。

3. 多模块交叉存储器的特点(优点)

   - 在不改变存取周期的前提下, 增加存储器的带宽
   - 设存储周期为 T; 总线传送周期为 t t<T; 模块数为 m
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230407000946169.png" alt="image-20230407000946169" style="zoom:50%;" />
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230407001018249.png" alt="image-20230407001018249" style="zoom:50%;" /> 
     - 设四模块交叉存储器，存取周期为T ，总线传输周期(连续两次在总线上传输数据信息的最小间隔)为 τ ，为实现流水线方式存取，应满足 $4 τ\geq T$ 
     - **连续读取4 个字**所需的时间为 $T ＋(4-1) τ$

4. > 例 : 设存储器容量为 32 字，字长 64 位，模块数 m=4 ，分别用顺序方式和交叉方式进行组织。存储周期 T=200ns ，数据总线宽度为 64 位，总线传送周期 τ =50ns 。若连续读出 4 个字，顺序存储器和交叉存储器的带宽各是多少

   - 读出 m=4 个字的信息总量是： $q=64 位 × 4=256 位$
   - 顺序存储器读出 4 个字所需的时间是：$t2=mT =4 × 200ns=800ns$
     交叉存储器读出 4 个字所需的时间是: $t1=T+(m1)=200ns+3 × 50ns=350ns$
   - 顺序存储器和交叉存储器的带宽分别是：$W2=q/t2=256÷ (8 × 10^{-7} )=32 × 10^7 ［位 /s ］ ;$
     $W1=q/t1=256÷ (3.5 × 10^{-7} )=73 × 10^7 ［位 /s ］$

## 3.6 Cache 存储器

- 疑问: Cache 和多模块交叉存储会不会冲突
  - 多模块交叉存储改变的只是地址的编排方式(连续的地址存储在不同模块中)
  - Cache 复制的是主存中连续地址的“块”, 存储到 Cache 中对应的“行”

### 3.6.1 Cache 的基本原理

1. Cache 概述

   - 原理： 基于程序和数据访问的局部性原理
   - 目标： 减少访存次数，加快运行速度
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230407001625603.png" alt="image-20230407001625603" style="zoom:33%;" />

2. 高速缓存的基本结构 (此结构全部由硬件实现, Cache 对程序员是透明的)

   ![image-20230407232550610](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230407232550610.png)

   - 存储体 : 基本单位为字，若干个字构成一个数据块；
   - 地址映射变换机构 : 用于将主存地址变换为 Cache 地址，以利用 CPU 发送的主存地址访问 Cache
   - 替换机构 : 若要更新 Cache 中数据时使用的机制；
   - 相联存储器 : Cache 的 块表 ，快速指示所要访问的信息是否在 Cache 中；
     - 块表 : 相当于 map, key : cache 行号, value : 主存块号
   - 读写控制

3. 高速缓存的访问过程

   1. CPU 输出**存储单元地址（字）**给内存， **Cache 获取地址**并分析；
   2. Cache 先判断该存储单元的内容是否已在 Cache 中；
      - 如果在， Cache 直接送给 CPU
      - 如果不在， CPU 再去主存中读取。
   3. CPU 去主存中读取存储单元时，不仅把该存储单元取出，
      同时还把该**存储单元附近的一块数据**()， 都取出送给 Cache,
      以便 CPU 顺序读取下一存储单元时，直接在 Cache 中读取。

#### Cache 的性能指标

- <font color='#66ccff'>命中率 h</font>：设一个程序执行期间，$N_c$表示 cache 完成存取的总次数，$N_m$表示主存完成存取的总次数，则命中率表示 CPU 要访问的信息在 Cache 中的比率 $h = \frac{N_c}{N_c+N_m}$ (一般>95%)
  - $失效率 = 1-命中率$
- 影响命中率的主要因素
  - **Cache 容量**：过小时，局部信息装不完，命中率低。过大时，对提高效率不明显，且成本高。
  - **Cache 中块的大小**：一般用一个主存周期所能调出的单元数（字或字节）作为一个块大小。
- t~c~为命中的 cache 访问时间，t~m~为未命中的主存访问时间，对存储系统的<font color='#66ccff'>平均访问时间 t~a~</font>： $t_a = h*t_c + (1-h)t_m$
  - t~a~ : 平均 average
  - t~c~ : cache
  - t~m~ : memory
- 系统<font color='#66ccff'>访问效率</font> <font size="5">$e = \frac{t_c}{t_a} (\frac{命中的cache访问时间}{平均访问时间})$ </font>
- <font size="5">设$\textcolor{#66ccff}{r}=\frac{t_m}{t_c}$, $e=\frac{t_c}{ht_c+(1-h)t_m} = \frac{1}{h+(1-h)r} = \frac{1}{r+(1-r)h}$ </font>

> 例 : CPU 执行一段程序， cache 完成存取的次数为 1900 次，主存完成存取次数为 100 次，已知 cache 存取周期为 50ns ，主存存取周期为 250ns, 求 cache/主存系统的效率和平均访问时间。

1. 法一

   - h = 1900/(1900+100) = 0.95

   - t~a~ =0.95\*50 + (1-0.95)\*250=60ns

   - e=50/60=83.3%

2. 法二
   - r = 250/50 = 5
   - $e = \frac{1}{r+(1-r)h}=\frac{1}{5+(1-5)*0.95}=83.3\%$
   - t~a~ = t~c~/e = 60ns

### 3.6.2 CPU 主存 Cache 的信息交换方式

1. CPU 与主存之间，以**字**为单位交换信息
   CPU 与 Cache 之间，以**字**为单位交换信息
2. Cache 与主存之间，以**块**为单位交换信息(一个块包含若干个字)

   - cache 的行和主存的块的大小一样
   - 访问一个内存地址时, 该字节所在的整个块都被读入到 Cache 对应的行中
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230409215927237.png" style="zoom: 33%;" />

3. 主存和缓存的编址

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410103619216.png" alt="image-20230410103619216" style="zoom:50%;" />

   - 主存和缓存按块存储块的大小相同 B 为块长/行大小

4. > 主存有 1MB ，主存块尺寸为 512 (2^9^)字节， Cache 尺寸为 128KB 。

   1. 主存有多少块 : $1M / 512=2^{20}/2^{9}=2048块$
   2. Cache 有多少行？$128K / 512=2^{17}/2^{9}=256行$
   3. 00008H 单元在主存的哪一块？第 1 块
   4. 04008H 单元的数据在主存的哪一块？
      - 4000H÷ 512 = 2^14^ ÷ 2^9^ = 2^5^ 第 32 块
      - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410104830059.png" alt="image-20230410104830059" style="zoom: 33%;" />

#### 主存与 Cache 地址映射方式

##### ① 全相连映射方式

1. 主存中每个块可复制到==任一行== 的 Cache 行中，块号地址存于标记

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410105205997.png" alt="image-20230410105205997" style="zoom:50%;" />

2. 全相连映射方式下的地址格式

   - 设主存共 2^n^个单元, 划分 2^s^个块 每块 2^w^个字 .Cache 分为 2^r^个行, 每行大小同主存的块
   - 主存地址格式：<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410105421434.png" alt="image-20230410105421434" style="zoom:33%;" />
   - Cache 地址格式 : <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410105447105.png" alt="image-20230410105447105" style="zoom:33%;" />
   - 当主存的数据块调入 Cache 中时， 该块的**s 位块号** （主存标记）保存于调入 Cache 行的**对应标记位**(即块表中)

3. CPU 读 Cache 的检索步骤

   1. 将块号与所有标记依次进行比较

   2. **命中**, 则根据块（行）内地址从 Cache 中读取该字；

   3. **不命中**, CPU 从主存中读取 (并复制一份到 Cache)

      <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410110435416.png" alt="image-20230410110435416" style="zoom: 50%;" />

   - 优点: cache 的利用率高。
   - 缺点: 比较次数过多，检索速度慢。

4. > 例 : 设主存容量 1MB, cache 容量 16KB ，块的大小为 512B ，采用全相连映射方式

   1. 写出 cache 的地址格式。（行地址 行内地址）

      - Cache 容量 16KB=2^14^B; 块(行)大小 512B=2^9^B
      - 行地址为 5 位 <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410113425424.png" alt="image-20230410113425424" style="zoom:50%;" />

   2. 写出主存的地址格式。（块号 块内地址）

      - 块地址 11 位 <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410113552260.png" alt="image-20230410113552260" style="zoom:50%;" />

   3. 块表的容量多大？

      - 2^5^\*11 位

        <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410113743637.png" alt="image-20230410113743637" style="zoom:50%;" />

   4. 画出地址映射及变换示意图

      <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410113819613.png" alt="image-20230410113819613" style="zoom:50%;" />

   5. 主存地址为 CDE8FH 的单元，在 cache 中的什么位置？

      - 主存地址为 CDE8FH 的单元可映射到 cache 中的**任何一个字块位置**；

5. `总结1` **全相连**映射方式的特点 : 主存中每个块可复制到任一行的 Cache 行中

   - 优点 :
     - 灵活性好 (最理想) : Cache 中只要有空行，就可以调入所需要的主存数据块；
   - 缺点
     - 成本高 : 标记位为 m 位，使 cache 标记容量变大；
     - 速度太慢 : 访问 cache 时，需将所有标记比较一遍，才能最后判出所需主存中的字块是否在 cache 中；

##### ② 直接映射方式

1. 主存与 cache 的划分方式同全相连。
   主存中每个块只能复制到**某一固定行**的 Cache 中，块号高位地址存于标记
   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410115939955.png" alt="image-20230410115939955" style="zoom:50%;" />

   - 相当于将主存块分区，每个区的大小与 Cache 大小相同
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410120025609.png" alt="image-20230410120025609" style="zoom: 67%;" />

2. 主存地址 ↔ Cache 行号

   - 假定主存有 32 个块 :B0~B31,cache 有 8 行： L0~L7
     L0 ↔ B0,B8,B16,B24
     $00\ \textcolor{#ee0000}{000}, 01\ \textcolor{#ee0000}{000}, 10\ \textcolor{#ee0000}{000}, 11\ \textcolor{#ee0000}{000}$ Cache 的第一行
     L1 ↔ B1,B9,B17,B25
     ……
     L7 ↔ B7,B15,B23,B31
   - $主存的地址 ↔ 区号/主存标记\ |\ (对应)Cache行号\ | \ 块内地址$
     - （对应）Cache 行号 = 内存块号 mod Cache 总行数
     - 区号/主存标记 = 内存块号/Cache 总行数

3. 直接映射方式下的主存地址格式

   - 主存共 2^n^个单元，分成 2^s^个块，每块单元数为 2^w^个
     - 主存地址为 s+w 位；
   - Cache 空间分成 2^r^行，每行大小也应为 2^w^单元
     - Cache 地址为 r+w 位；
   - 直接映射中主存块与 Cache 行的关系：
     - 主存的$(2^s / 2^r )= 2 ^{s+r} $个块映射于 Cache 的同一行；
     - 主存地址中的 r 位决定该主存块对应的 Cache 行 s-r 位为主存标记
       - 块表的大小应为 $2^r × (s-r)$ 位
     - 主存的地址格式为：<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410185246846.png" alt="image-20230410185246846" style="zoom:33%;" />

4. CPU 读 Cache 检索步骤

   1. 利用行号定位 Cache 中的某一行
   2. 将 Tag 与该行标记器中的值进行比较
   3. 命中，则根据块内地址从 Cache 中读取该字

   - 优点：比较简单，速度高。
   - 缺点: 块的冲突高，利用率低。
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410185421327.png" alt="image-20230410185421327" style="zoom: 50%;" />

5. > 设主存容量 1MB ，高缓容量 16KB ，行的大小为 512B ，采用直接映射：
   > (1) 写出主存每部分地址位长 (2) CACHE 地址格式；
   > (3) 行标记的容量为多大 (4) 画出直接地址映像关系

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410185815421.png" alt="image-20230410185815421" style="zoom:50%;" />

6. 设主存容量 1MB cache 容量 16KB ，块的大小为 512B ，采用直接映射方式

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410190436903.png" alt="image-20230410190436903" style="zoom:50%;" />

   1. 块表的容量多大？ 主存标记长度, 64
   2. 画出地址映射及变换示意图。
      <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230410191902221.png" alt="image-20230410191902221" style="zoom:50%;" />
   3. 主存地址为 CDE8FH 的单元在 cache 中的什么位置？
      - 主存地址 CDE8FH 1100 11**01 111**0 1000 1111
      - 对应于 Cache 的第 01111 行，行内地址为 0 1000 1111

7. `总结2` 直接 映射方式的特点 : 一个主存块只能调入 cache 的一个特定行中

   - 优点
     - 该映射函数实现简单，查找速度快；
     - 主存地址的中间 c 位即为 Cache 的行地址；
     - 在对应的块表中使用高 t 位地址进行比较，决定是否命中；
   - 缺点
     - 灵活性差；
     - 主存的 2^t^个字块只能对应唯一的 Cache 字块，即使 Cache 中别的字块空着也不能占用。

##### ③ 组相联映射方式

1. 将 Cache 与主存分组，设 Cache 中分成 u(2^d^) 个组，每组 v(2^v’^) 个行 即 r= d+v’。
   主存中一个组的块数与 Cache 中的分组数相同。

   - 主存中的各块与 Cache 的组号有固定的映射关系 但可自由映射到对应的 Cache 组中的任何一行。
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230412165148707.png" alt="image-20230412165148707" style="zoom: 33%;" />

2. 映射关系

   - 将 Cache 中的行等分为若干组，主存中的每一块只能映射到 Cache 的特定组中，但是可调入到该组的任一行中；
     组间为直接映射，组内为全相联映射
     - 全连:块 → 随意行
     - 直接:块 → 指定行
     - 组相联:块 →**指定组**→ 组内的随意行
     - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230412215307875.png" alt="image-20230412215307875" style="zoom:50%;" />
   - 设 j 表示主存块号， Cache 共 u 组，则映射函数: $组号q= j\ mod\ u$
   - 当 Cache 的一组包含 r 行时，通常称为 <font color='#66ccff'>r 路组相联映射</font>

3. CPU 读 Cache 检索步骤

   1. 利用组号定位 Cache 中的某一组
   2. 将 Tag 与组内所有行的标记器中的值依次进行比较
   3. 命中，则根据块内地址从 Cache 中读取该字

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230412215421015.png" alt="image-20230412215421015" style="zoom:50%;" />

4. `总结3`组相连映射方式的特点 : 组间为直接映射，组内为全相联映射

   - 灵活性：比直接映射灵活（主存可映射到组内任一块）；
   - 快速性：比全相联比较次数少，只需组内全部比较；
   - 由于比较次数少，电路也较易于实现。

> 三种不同映射方式的比较
>
> ![image-20230412215538562](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230412215538562.png)

#### Cache 的替换策略

1. 最不经常使用算法 LFU
   - 替换对象：一段时间内==被访问次数最少== 的那行
   - 每行需设置**计数器**; 从 0 开始, 每访问一次被访行的计数器增 1
   - 需要替换时比较各特定行的计数值，将计数值**最小**的行换出。
2. 最近最少使用算法 LRU
   - 替换对象： 最近一段时间==最久未被访问== 的那行
   - 每行需设置**计数器**; 每访问一次，被访行的计数器清零, 其它各行计数值增 1
   - 需要替换时比较各特定行的计数值，将计数值**最大**的行换出。
3. 先进先出算法 FIFO
4. 随机替换: 从特定的行位置中==随机地选取一行== 换出

#### Cache 的读过程

读 将主存地址同时送往主存和 Cache

- Cache 命中: 从 Cache 读
- Cache 失败: 从主存读

#### Cache 的写操作策略

- 写回法: Cache 行只有被替换时, 才写入主存
- 全写法: 同时写 Cache 和主存
- 写一次法: 第一次写时, 同时写 Cache 和主存

​ <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/2021011817132510.png" alt="img" style="zoom:50%;" />

## 3.7 虚拟存储器

![img](https://img-blog.csdnimg.cn/2021011818453286.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

### 3.7.1 虚拟存储器的基本概念

- <font color='#66ccff'>虚拟存储器</font> : 指主存——辅存层次的存储系统, 借助于**辅助存储器**来扩大主存容量，
  - 辅助存储器对 CPU 而言是“虚拟的”。
  - 虚拟存储器是指一个大容量的存储**逻辑模型** ，不是实际物理存储器。
- <font color='#66ccff'>物理地址</font>：由 CPU 地址引脚 送出的地址信号，是 CPU 用于访问 主存 的地址 。
  - 对应的存储空间为**实地址** 或 **物理地址**
- <font color='#66ccff'>逻辑地址</font>：由编译程序生成 ，是用户编写程序时用于访问程序的 逻辑地址

  - 对应的存储空间称为**虚存空间** 或 **逻辑地址空间** 。
  - 其地址空间大小受到辅助存储器容量的限制。

- Cache 与虚存

  - 相同点

    - **出发点**相同：提高存储系统的性能；
    - **原理**相同： 程序运行时的局部性原理
    - Cache——主存 与 主存——辅存 的 **地址变换映射方式**和**替换策略**都 类似

  - 不同点

    |            | Cache                                                                | 虚拟存储器                                                                                        |
    | ---------- | -------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
    | 目的       | 弥补**速度**的差距                                                   | 弥补主存**容量** 的不足                                                                           |
    | 数据通路   | 存在**可直接访问**通路                                               | 不存在**可直接访问**通路 (CPU 不能直接访问辅存)                                                   |
    | 透明性     | 主存—Cache 之间地址变换、数据替换**全部由硬件实现**对程序员 完全透明 | 主存—辅存之间地址变换、数据替换由**操作系统中的存储管理软件**辅助一些硬件共同实现，对系统程序可见 |
    | 未命中损失 | 主存的读写时间是 Cache 读写时间的 **5~10** 倍                        | 硬磁盘的读写时间是主存的**千倍** ，则主存未命中时的系统性能损失很大                               |

### 3.7.2 页式虚拟存储器

> Cache—主存以块(Cache 中叫行)为基本单位交换信息; 与之相似 主存—辅存以页为基本单位交换数据

1. <font color='#66ccff'>页式虚拟存储器</font>：以<font color='#66ccff'>页</font>为基本单位与主存交换数据。

   - 主存空间也分成同样大小的页
   - 主存分成的页称为<font color='#66ccff'>实页</font><font color='orange'>(类比 Cache 的行)</font> ，虚拟存储器分成的页称为 <font color='#66ccff'>虚页</font><font color='orange'>(类比主存中的块)</font>

2. 地址

   - <font color='#66ccff'>虚地址</font>: 分为两个字段：虚页号 + 页内地址。
   - <font color='#66ccff'>实地址</font>: 分为两个字段：实页号 + 页内地址。
   - 由于虚页与实页大小一样 ，所以==页内地址是相等== 的。
   - 虚页号与 实页号 之间的变换是通过查找 主存中 的 <font color='#66ccff'>页表</font> 来实现的。

3. 页式虚拟存储器

   - 优点：页面的起点和终点地址是 固定的 ，方便造页表，新页调入 主存也 很容易掌握，页外空间浪费少。
   - 缺点：处理、保护、共享都不方便。
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419132341328.png" alt="image-20230419132341328" style="zoom:50%;" />

4. 页表的改进

   - > 每次访存， CPU 都要先访问主存中的页表, 通过逻辑页号**查找**实页号，拿到实地址后，再按实地址访问主存单元

   - 将逻辑页号作为数组下标, O(1)查找 <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419132817441.png" alt="image-20230419132817441" style="zoom:50%;" />

   - 通常，把页表最活跃部分放在 Cache 中组成 <font color='#66ccff'>快表</font>； 保存在主存的完整页表是 <font color='#66ccff'>慢表</font>。
     快表由 硬件（ TLB ）构成 ，减少访存开销

5. 虚实地址转换过程：

   1. 存储管理模块读页表起始地址到 页表基址寄存器
   2. 页表基址寄存器 虚页号拼成页表索引地址
   3. 查找该页在页表中信息字
   4. 检测装入位
      1. 若为 ”1”, 则形成实地址: 读取实页号作为实地址高位地址 虚地址的页内行地址作为实地址低 ,CPU 以此访问主存
      2. 若为 “0” , 以中断方式把虚地址指示的一页内容从辅存调入主存 再提供给 CPU 访问
   5. <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419133315437.png" alt="image-20230419133315437" style="zoom:50%;" />

6. > 例：在页式虚拟存储器中，若主存容量为 4MB ，虚存容量为 1GB ，则虚地址和物理地址各为多少位？ 页面容量为 4KB ，则页表长度为多少行

   - 物理地址 22 位; 虚地址 30 位
   - 虚页号字段位数 18, 页表长度 2^18^行

7. > 【例】 采用页式虚拟存储器，页表索引地址由页表基址寄存器和虚页 号拼接 而成，已知某程序中一条指令的虚地址 是 00 0001 1111 1110 0000 ，页表起始地址为 0011 ，页面大小 1K, 按以下页表查找实地址。

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419134320000.png" alt="image-20230419134320000" style="zoom:50%;" />

### 3.7.3 段式虚拟存储器

1. 将程序按照逻辑结构分成若干段， 各段大小可变

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419160541952.png" alt="image-20230419160541952" style="zoom:50%;" />

2. 建立段表：

   - 段起址：当该段装入主存时 记录其在主存中的起始地址。

3. 虚地址组成: 段号（高位）+ 段内地址（低位）

4. 虚实地址转换过程：

5. 优缺点

   - 优点 ：便于程序运行
   - 缺点 ：存储管理复杂，存储空间利用率低。

### 3.7.4 段页式虚拟存储器

- 将程序按照逻辑结构分成若干段，各段再分成大小相同的页
- 主存按页划分，大小与虚页同，以页为单位装入；
- 建立段表和页表。
- ![image-20230419160911136](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419160911136.png)

把程序按逻辑结构分段，每段再划分为固定大小的页， 主存空间也划分为大小相等的页， 程序对主存的调入、调出仍以页为基本传送单位。 每个程序对应一个段表，每段对应一个页表 虚拟地址：段号+段内页号+页内地址

### 3.7.5 虚存的替换算法

1. FIFO

   - 主存只允许存放 3 个页，标记为 a,b,c 请给出命中率
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419161101840.png" alt="image-20230419161101840" style="zoom:50%;" />
   - 命中 2, 命中率:2/11=18.2%

2. FIFO 算法+LRU

   - 如果某个页面命中，则将该页面移动到 FIFO 的入口位置
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419161203393.png" alt="image-20230419161203393" style="zoom:50%;" />
   - 命中 3, 命中率 3/11=27.3%

3. LRU

   - 每页设置一个计数器每次命中一页 该页对应的计数器清零其他各页的计数器加 1 ；需要替换时, 计数值最大的页换出

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419161255591.png" alt="image-20230419161255591" style="zoom:33%;" />

   - > 例：某 虚拟存储器采用页式存储管理，使用 LRU 页面替换算法，若每次访问在一个时间单位内完成，页面访问序列如下： 1 、 8 、 1 、 7 、 8 、 2 、 7 、 2 、 1 、 8 、3 、 8 、 2 、 1 、 3 、 1 、 7 、 1 、 3 、 7 。
     >
     > 已知主存只允许放 4 个页面，初始状态时 4 个页面是全空的，则页面失效次数是多少？

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419161345399.png" alt="image-20230419161345399" style="zoom:50%;" />

## 3.8 本章开头提出的问题回答

1. 存储器的层次结构主要体现在何处？为何要分这些层次？计算机如何管理这些层次？

   - 存储器的层次结构主要体现在**Cache-主存**和**主存-辅存**这两个存储层次上。
   - Cache-主存层次在存储系统中主要对 CPU 访存起加速作用，即从整体运行的效果分析，CPU 访存速度加快，接近于 Cache 的速度，而寻址空间和位价却接近于主存。
   - 主存-辅存层次在存储系统中主要起扩容作用，即从程序员的角度看，他所使用的存储器的容量和位价接近于辅存，而速度接近于主存。
   - 综合上述两个存储层次的作用，从整个存储系统来看，就达到了速度快、容量大、位价低的优化效果。 主存与 Cache 之间的信息调度功能全部由硬件自动完成。而主存与辅存层次的调度目前广泛采用虚拟存储技术实现，即将主存与辅存的一部分通过软/硬结合的技术组成虚拟存储器，程序员可用这个比主存实际空间（物理地址空间）大得多的虚拟地址空间（逻辑地址空间）编程，当程序运行时，再由软/硬件自动配合完成虚拟地址空间与主存实际物理空间的转换。因此，这两个层次上的调度或转换操作对于程序员来说都是透明的。

2. 存取周期和存取时间有何区别？
   - 存取周期和存取时间的主要区别是：存取时间仅为完成一次操作的时间；而存取周期不仅包含操作时间，而且包含操作后线路的恢复时间，即存取周期=存取时间+恢复时间。(这是不是也可以解释，为什么 IC 前端，时序分析中有建立时间和保持时间吧)
3. 在虚拟存储器中，页面是设置得大一些好还是设置得小一些好？
   - 页面不能设置得过大，也不能设置得过小。
   - 因为页面太小时，平均页内剩余空间较少，可节省存储空间，但会使得页表增大，而且页面太小时不能充分利用访存的空间局部性来提高命中率；
   - 页面太大时，可减少页表空间，但平均页内剩余空间较大，会浪费较多存储空间，页面太大还会使页面调入/调出的时间较长

## 3.9 常见问题

### 1.存取时间 Ta 就是存储周期 Tm 吗？

- 1.存取时间 Ta 就是存储周期 Tm 吗？ 不是。<font color="blur" size="4">存取时间 Ta</font>是执行一次读操作或写操作的时间，分为读出时间和写入时间。读出时间是从主存接收到有效地址开始到数据稳定为止的时间；写入时间是从主存接收到有效地址开始到数据写入被写单元为止的时间。 <font color="blur" size="4">存储周期 Tm</font>是指存储器进行连续两次独立地读或写操作所需的最小时间间隔。所以存取时间 Ta 不等于存储周期 Tm。通常存储周期 Tm 大于存取时间 Ta。

### 2. Cache 行的大小和命中率之间有什么关系？

- 2.Cache 行的大小和命中率之间有什么关系？ 行的长度较大，可以充分利用程序访问的空间局部性，使一个较大的局部空间被一起调到 Cache 中，因而可以增加命中机会。但是，行长也不能太大，主要原因有两个： 1)行长大使失效损失变大。也就是说，若未命中，则需花更多时间从主存读块。 2)行长太大， Cache 项数变少，因而命中的可能性变小

### 3.发生取指令 Cache 缺失的处理过程是什么？

- 3.发生取指令 Cache 缺失的处理过程是什么？ 1)程序计数器恢复当前指令的值。 2)对主存进行读的操作。 3)将读入的指令写入 Cache 中，更改有效位和标记位。 4)重新执行当前指令。

### 4.关于 Cache 的一些小知识

- 4.关于 Cache 的一些小知识。 1)**多级 Cache**。现代计算机系统中，一般采用多级的 Cache 系统。CPU 执行指令时，先到速度最快的一级 Cache( LI Cache)中寻找指令或数据，找不到时，再到速度次快的二级 Cache(L2 Cache)中找…最后到主存中找。 2)**指令 Cache 和数据 Cache**。指令和数据可以分别存储在不同的 Cache 中（ LI Cache 一般会这么做），这种结构也称哈佛 Cache,其特点是允许 CPU 在同一个 Cache 存储周期内同时提取指令和数据，由于指令执行过程取指和取数据都有可能访问 Cache,因此这一特性可以保证不同的指令同时访存。

![img](https://img-blog.csdnimg.cn/20210119195316544.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

# 第四章 指令系统

## 【复习提示】

指令系统是表征一台计算机性能的重要因素。读者应注意扩展操作码技术，各种寻址方式的特点及有效地址的计算，相对寻址有关的计算，CISC 与 RISC 的特点与区别。本章知识点出选择题的概率较大，但也有可能结合其他章节出有关指令的综合题。2014 年、2015 年已连续两次出现指令系统和指令流水线的大题。指令系统格式和指令寻址方式与 CPU 指令执行过程部分紧密结合，希望读者引起重视。

在学习本章时，请读者思考以下问题

1. 什么是指令？什么是指令系统？为什么要引入指令系统？
2. 一般来说，指令分为哪些部分？每部分有什么用处？
3. 对于一个指令系统来说，寻址方式多和少有什么影响？

请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。 ![img](https://img-blog.csdnimg.cn/20210119075927711.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

## 4.1 指令系统概述

1. <font color='#66ccff'>指令</font>：指示计算机执行某种操作的命令。
   - 微指令：硬件指令
   - 机器指令：硬件与软件的接口。
   - 硬件的任务是执行指令。
   - 指令的序列构成程序。
   - 宏指令：软件指令（语句）
2. <font color='#66ccff'>指令系统</font>：一台计算机所有机器指令的集合。它代表了一台计算机的硬件功能。

   - 复杂指令系统（CISC）
   - 精简指令系统（RISC)

3. 计算机指令系统的发展过程
   - 50 年代
     只有定点加减、逻辑运算、数据传送、转移等十几至几十条指令。
   - 60 年代后期
     增加了乘除运算、浮点运算、十进制运算、字符串处理等指令，
     指令数目多达一二百条，寻址方式也趋多样化。
     出现了系列计算机。
   - 70 年代末期
     复杂指令系统计算机(CISC)、精简指令系统计算机(RISC)
4. <font color='#66ccff'>复杂指令系统 CISC</font> (complex instruction set computer)
   - 每条指令的功能都很强大
     通过复杂的的指令系统，来达到增强计算机的功能、提高机器速度的目的。
   - 特点：
     1. 指令系统复杂庞大，指令数目多；
     2. 指令格式多，字长不固定，多种寻址方式；
     3. 可访存指令不受限制；
     4. 各种指令的执行时间相差很大；
     5. 大都采用微程序控制器；
5. <font color='#66ccff'>精简指令系统 RISC</font> (Reduced instruction set computer)
   - 从简化指令系统 和 优化硬件设计 的角度来提高系统的性能与速度。
   - RISC 指令系统的主要特点：
     1. 选取使用频率高的简单指令；
     2. 指令长度固定，指令格式少，寻址方式种类少；
     3. 采用流水线技术；
     4. 使用较多的通用寄存器，减少访存；
     5. 控制器以组合逻辑控制为主；
     6. 采用优化编译技术；

### 4.2 指令的格式

- 指令字：机器指令用机器字表示 称为指令字 简称指令 。
- 指令的格式：指令字用 二进制代码 表示的结构形式：
  1. 操作码 字段：表示指令的操作特性与功能 。
  2. 地址码 字段：表示参与操作的操作数的地址, 含被操作数地址 、操作数地址和操作结果地址 。
- 指令的功能： 根据操作码对地址码提供的操作数完成某种操作

### 4.2.1 操作码

- 每条指令都要规定一个操作码
- 不同的指令用（操作码字段的）不同编码表示， 操作码的位数与指令规模有关 。
  - 固定长度操作码
    - 优点：简化硬件设计，减少译码时间。
    - 缺点：操作码的平均长度长，需要指令字长长。
    - 一般用于大中型机和超级小型机。
  - 可变长度操作码（操作码扩展技术） <font color='orange'>(如哈夫曼编码) </font>
    - 优点：根据地址码长度调整，可以压缩操作码的平均长度。
    - 缺点：控制器的设计相对较复杂，指令的译码时间也较长。
    - 为提高速度，一般 使用频度高的指令分配短的操作码；使用频度低的指令分配长的操作码。
  - 一般用于微、小型机。

### 4.2.2 地址码

根据指令中有几个操作数可分成三地址 、 二地址 、 一地址 和零地址 几种结构形式。

1. 零地址指令
   - 格式: `OP`
   - 这种指令字不含地址码字段，有两种可能：
     - 不需要操作数 的指令；
     - 所需操作数都是==隐含指定== 。(如`pushad`)
2. 一地址指令
   - 格式: `OP | A`
   - 功能
     - 单操作数: `OP(A) → A` 如`inc eax eax=(eax)+1`
     - 双操作数: `(AC) OP (A) → AC` AC 隐含约定
     - 使用 ==隐地址== 可以减少指令中的地址数，简化地址结构 。
3. 二地址指令
   - 格式: `OP | A1 | A2`
   - 功能:
     - `(A1) OP (A2)→ A1`
     - `OP (A2) → A1`
   - 二地址指令格式中，根据操作数的 物理位置 可分为三类：
     - <font color='#66ccff'>存储器—存储器（ SS ）型</font>: 参与操作的数都放在内存里。
     - <font color='#66ccff'>寄存器—寄存器（ RR ）型</font>: 参与操作的数都放在寄存器里。
     - <font color='#66ccff'>寄存器—存储器（ RS ）型</font>: 一个操作数在内存，一个在寄存。
4. 三地址指令
   - 格式: <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419165813415.png" alt="image-20230419165813415" style="zoom:33%;" />
   - 功能：`(A1) OP (A2) → A3`

#### 指令的操作码扩展技术（补充）

- 一个指令系统中
  - 若操作码长度固定且指令格式不同；
  - 指令格式如右：
    <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419170600156.png" alt="image-20230419170600156" style="zoom:50%;" />
  - 操作码字段长度取决于指令系统中的指令总数目；
  - 地址码较少的指令，编码浪费；
- **操作码扩展**

  - 对于不需要某个地址码的指令，把它们的操作码扩充到该地址字段；
  - 既充分利用指令字的各字段，又在不增加指令长度的情况下扩展操作码的长度。

- 操作码拓展举例
  - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419170739325.png" alt="image-20230419170739325" style="zoom:33%;" /> 该指令系统一共具有 61 条指令
  - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230419171012295.png" alt="image-20230419171012295" style="zoom:33%;" /> 此指令系统共具有 75 条指令
    <font color='orange'>零地址 应该还能往下扩充吧</font>

### 4.2.3 指令字长度

指令字长度为一个指令字中包含二进制代码的位数。

- 机器字长 ：计算机能直接处理的二进制数据的位数，它决定了计算机的运算精度。
- 根据指令字长与机器字长关系将指令分为：单字长指令、半字长指令、双（多）字长指令
- 一个指令系统根据指令字长可分为：变长指令格式、固定长指令格式

### 4.2.4 指令助记符

<font color='#66ccff'>指令助记符</font>是指令代码的符号化 。

- 不同计算机助记符规定不一样；
- 助记符必须转换成代码机器才可识别。

## 4.3 操作数的类型

- <font color='#66ccff'>地址数据</font>: 无符号整数，通过某种运算确定操作数在主存中的有效地址；
- <font color='#66ccff'>数值数据</font>: 定点整数、小数；浮点数；压缩十进制数；
- <font color='#66ccff'>字符数据</font>: 文本数据或字符串；
- <font color='#66ccff'>逻辑数据</font>: 由若干二进制位组成，每位的值可以是 1 或 0

## 4.4 指令和数据的寻址方式

- 存储器数据读写方式： <font color='#66ccff'>地址指定方式</font> 、相联存储方式和堆栈存取方式。
  - 地址码给出的地址值不一定能直接使用，需根据寻址方式得到可用的地址
- 寻址方式： 地址指定方式中 ，形成操作数或指令地址的方式。
- 冯诺依曼型计算机中，内存中指令的寻址和数据的寻址是交替进行的。

### 4.4.1 指令的寻址方式

1. 顺序寻址方式
   - 当程序按顺序执行时的指令寻址方式；
   - 必须用<font color='#66ccff'>程序计数器 PC</font>记录所要执行指令的存放单元地址；
     - 一般做顺序加 1 的操作；
     - 程序计数器又称 指令指针寄存器
2. 跳跃寻址方式
   - 当程序转移执行时的指令寻址方式；(JMP 指令跳转)
   - 程序计数器的内容由本条指令给出，而不是顺序改变。

<img src="C:/Users/14258/AppData/Roaming/Typora/typora-user-images/image-20230420232136722.png" alt="image-20230420232136722" style="zoom:50%;" />

### 4.4.2 操作数的寻址方式

- 操作数的寻址方式说明了形成操作数的有效地址的方法 。
- 寻址方式的含义有二个
  1. 要表示指令所需的**操作数在何处** （如在寄存器中或主存单元中）
  2. 要给出**获取操作数地址**的方法。
- 指令中表达寻址方式的方法
  - 操作码**隐含**说明不同寻址方式
  - 指令中设置专门字段**说明**寻址方式
- 关于地址的术语：
  - <font color='#66ccff'>有效地址</font>（<font color='#66ccff'>物理地址 EA</font> ）：可以直接取数的地址
  - <font color='#66ccff'>形式地址</font>（ <font color='66ccff'>偏移量 A</font> ）：地址须变换<font color='orange'>(A→EA)</font>才可取地址

#### 寻址方式

1. 隐含寻址
   - 操作数的地址不由地址码指明，而是隐含在操作码中 。
   - 特点：不访问存储器； 指令字中少了一个地址字段，可缩短指令字长；
   - 例如: 8086 的 `MUL `指令 ：被乘数隐含在 AX (16 位) 或 AL (8 位) 中
2. 立即寻址 (立即数)
   - 指令地址段直接给出操作数 <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230421164037604.png" alt="image-20230421164037604" style="zoom: 33%;" />
     `D = A`
   - 特点:
     - 指令执行阶段不需要访存，速度快；
     - 形式地址 A 字段的位数限制了立即数的范围
3. 直接寻址
   - 指令直接给出操作数地址 ，根据该地址可从主存单元中读取操作数。
     寻址过程可描述为：`EA = A`/ `D=(A)`
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230421164325108.png" alt="image-20230421164325108" style="zoom: 33%;" />
   - 特点：
     - 执行阶段访问一次存储器
     - A 的位数 决定了该指令 操作数的**寻址范围**
     - 操作数的地址不易修改(必须修改 A)
4. 间接寻址
   - 指令给出存放操作数地址的主存单元地址 ，即操作数的间接地址。
     寻址过程可描述为：`EA = (A)` / `D=(EA)=((A))` <font color='orange'>两次寻址</font>
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230421164625985.png" alt="image-20230421164625985" style="zoom: 33%;" />
   - 特点：
     - 执行阶段访问多次存储器
     - A 的位数 受指令**字长**和格式的限制；
     - 可以根据间接寻址标志字段区分
5. 寄存器寻址
   - 指令中给出寄存器号（也称寄存器地址） 从寄存器中获取操作数 。
     寻址过程可描述为：`EA=Ri` / `D=(Ri)`
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230421164835328.png" alt="image-20230421164835328" style="zoom:33%;" />
   - 优点
     - 寻址速度快 <font color='orange'>(不访问存储器)</font>
     - 可以减少一个操作数地址的位数, 缩短指令字长 <font color='orange'>(因为只需要指定寄存器)</font>
6. 寄存器间接寻址

   - 操作数在主存单元中，由指令给出寄存器号，该寄存器存放操作数地址 。
     寻址过程可描述为：`EA=(Ri)`/ `D=((Ri))`
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230421165028197.png" alt="image-20230421165028197" style="zoom:33%;" />
   - 优点
     - 寻址速度较快(比间接寻址快) (访问存储器一次)
     - 可以减少一个操作数地址的位数

7. 偏移寻址: 有效地址由寄存器内容加一偏移量组成
   - 直接寻址和寄存器间接寻址方式的结合
   - 有效地址 EA=A+(R)
     - A 是显式的形式地址字段；
     - R 可以是显式的，也可以隐含的，某个专用的寄存器；
   - 常用的偏移寻址
     - <font color='#66ccff'>相对寻址</font>：指令转移时，常用相对寻址方式 `EA = A+(PC)` <font color='orange'>即相对 PC 寻址</font>
     - <font color='#66ccff'>基址寻址</font>: `EA=(基址R)+A, A+1→A`
     - <font color='#66ccff'>变址寻址</font>: `EA=A+(变址R) ，变址R+1→变址R`
8. 偏移寻址—相对寻址
   - 用程序计数器 PC 的内容作为基准地址，指令中给出的形式地址作为位移量（可正可负），二者相加后形成
     操作数的地址。
     寻址过程可描述为：`EA=(PC)+A`/`D=((PC)+A)`
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230421170552756.png" alt="image-20230421170552756" style="zoom:33%;" />
   - 特点：
     - 隐含引用专用寄存器 PC
     - 操作数地址随 PC 内容变化而改变 ，但二者之间的距离不变，可使操作数与指令在主存中一起移动；
     - 位移量 A 可正可负，表示操作数地址可以在指令地址之后或之前。
9. 偏移寻址—基址寻址
   - 指令给出一个形式地址，指定 CPU 中一个寄存器作为**基址寄存器**， 将基址寄存器内容（作为基准量）与形式
     地址相加得到操作数地址。
     寻址过程可描述为：`EA=(Ri)+A`/ `D=((Ri)+A)`
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230421171421770.png" alt="image-20230421171421770" style="zoom:33%;" />
10. 偏移寻址—变址寻址
    - 指令给出一个形式地址，并给出变址寄存器号；
      形式地址（作为基准量）与**变址寄存器**内容相加得到操作数地址
      寻址过程: `EA=A(基址)+(Ri)(变址)`or `D=(A+(Ri))`
    - 基址寻址&变址寻址
      - 变址寻址面向用户，用于访问字符串、线形表、一维数组等；
      - 基址寻址面向系统，用来解决程序在主存中重定位的问题，以及在有限字长指令中扩大寻址空间等。
11. 段寻址
    - 指令给出一个形式地址，CPU 中设有专用寄存器作为段基址寄存器， **先对段寄存器进行固定操作后**再与形式
      地址相加得到操作数地址
    - 例 x86 机寻址为： `S=((R)段x16+A)`
      在段地址寄存器仅有 16 位的情况下，有 1M 的寻址能力
12. 堆栈寻址方式
    - 堆栈 ：计算机中 暂时存储数据的存储单元 ，分成寄存器堆栈和存储器堆栈。
      - 存储数据特点： 后进先出 。
    - 寄存器堆栈 ：在 CPU 中设有一组专门的寄存器，采用串联方式进、出栈。
      - 进、出栈地址不变，数据位置改变。
    - 存储器堆栈：在 主存 中分配一块存储单元， 指令隐含约定由堆栈指针专用寄存器（ SP ）提供堆栈栈顶单元地址，进行读出或写入。
      - 进、出栈的地址变化，数据位置不变。
    - 存储器堆栈寻址过程：
      <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230421172116551.png" alt="image-20230421172116551" style="zoom:33%;" />

#### 例题

1. > 一种二地址 RS 型指令的结构如下所示：<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230421172528389.png" alt="image-20230421172528389" style="zoom: 50%;" /> 其中
   > I 为间接寻址标志位， X 为寻址模式字段， D 为偏移量字段。通过 I,X,D 的组合，可构成如下所示的寻址方式。
   >
   > 请写出 6 种寻址方式的名称。

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230421172609233.png" alt="image-20230421172609233" style="zoom:50%;" />

2. > 某计算机字长为 16 位，主存容量为 64K 字，采用单字长单地址指令，共有 40 条指令。试采用直接、立即、变址、相对四种寻址方式设计指令格式

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230612170433489.png" alt="image-20230612170433489" style="zoom:50%;" /> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230612170616271.png" alt="image-20230612170616271" style="zoom:50%;" />

3. > 某 16 位机器所使用的指令格式和寻址方式如下所示，该机有两个 20 位基址寄存器，四个 16 位变址寄存器，十六个 16 位通用寄存器， 指令汇编格式中的 S(源), D(目标)都是通用寄存器 M 是主存中的一个单元 。
   >
   > 三种指令的操作码分别是 MOV (OP )=(A) H; STO (OP) = (1B) H; LAD (OP) = (3C) H 。 MOV 是传送指令， STO 为存
   > 数指令， LAD 为取数指令。

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230612170814066.png" alt="image-20230612170814066" style="zoom:50%;" />

   1. 分析三种指令的指令格式与寻址方式特点。

      - 第一种指令是 单字长 二地址指令， **RR 型**
      - 第二种指令是 双字长 二地址指令， **RS 型** ，其中 S 采用基址寻址或变址寻址，R 由源寄存器决定
      - 第三种指令是 双字长 二地址指令， **RS 型** ，其中 R 由目标寄存器决定， S 由 20 位地址（直接寻址）决定

   2. CPU 完成哪一种操作所花时间最短？哪一种操作所花时间最长？第二种指令的执行时间有时会等于第三种指令的执行时间吗？

      - 第一种指令所花时间最短；RR 型指令，不需要访问存储器。
      - 第二种指令所花时间最长；RS 型指令，需要访问存储器，同时要进行寻址方式的变换运算（基址或变址），这也需要时间
      - 第二种指令的执行时间不会等于第三种指令; 第三种指令虽然也访问存储器，但节省了求有效地址运算的时间开销。

   3. 下列情况下每个十六进制指令字分别代表什么操作？其中如果有编码不正确，如何改正才能成为合法指令？

      - > MOV(OP) = (A) H = 001010
        > STO(OP) = (1B) H = 011011
        > LDA(OP) = (3C) H = 111100

      - ![image-20230612175411706](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230612175411706.png)

## 4.5 本章开头提出的问题回答

1. 什么是指令？什么是指令系统？为什么要引入指令系统？

   - 指令就是要计算机执行某种操作的命令，一台计算机中所有机器指令的集合，称为这台计算机的指令系统。
   - 引入指令系统后，避免了用户与二进制代码直接接触，使得用户编写程序更为方便。
   - 另外，**指令系统**是表征一台计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围。

2. 一般来说，指令分为哪些部分？每部分有什么用处？

   - 一条指令通常包括操作码字段和地址码字段两部分。
   - 操作码指出指令中该指令应该**执行什么性质的操作和具有何种功能**，它是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息。
   - 地址码用于给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等。

3. 对于一个指令系统来说，寻址方式多和少有什么影响？
   - 寻址方式的多样化能让用户编程更为方便，但多重寻址方式会造成 CPU 结构的复杂化（详见下章），也不利于指令流水线的运行。
   - 而寻址方式太少虽然能够提高 CPU 的效率，但对于用户而言，少数几种寻址方式会使编程变得复杂，很难满足用户的需求。

## 4.5 常见问题

### ① 简述各常见指令寻址方式的特点和适用情况

- 立即寻址操作数获取便捷，通常用于给寄存器赋初值。
- 直接寻址相对于立即寻址，缩短了指令长度
- 间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回。
- 寄存器寻址的指令字较短，指令执行速度较快
- 寄存器间接寻址扩大了寻址范围。
- 基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间。
- 变址寻址主要用于处理数组问题，适合编制循环程序。
- 相对寻址用于控制程序的执行顺序、转移等。
  - 基址寻址和变址寻址的区别：两种方式有效地址的形成都是寄存器内容+偏移地址，但是在基址寻址中，程序员操作的是偏移地址，基址寄存器的内容由操作系统控制，在执行过程中是动态调整的；而在变址寻址中，程序员操作的是变址寄存器，**偏移地址是固定不变**的。

### ② 一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址？

- 现代计算机都采用字节编址方式，即一个内存单元只能存放一字节的信息。
- 一个操作数（如 char、int、foat、 double)可能是 8 位、16 位、32 位或 64 位等，因此可能占用 1 个、2 个、4 个或 8 个内存单元。也就是说，一个操作数可能有多个内存地址对应。
- 有两种不同的地址指定方式：大端方式和小端方式。
  - 大端方式：指令中给出的地址是操作数最高有效字节(MSB)所在的地址
  - 小端方式：指令中给出的地址是操作数最低有效字节(LSB)所在的地址。

### ③ 装入/存储(Load/ Store)型指令有什么特点？

- 装入/存储型指令是用在规整型指令系统中的一种通用寄存器型指令风格。这种指令风格在 RISC 指令系统中较为常见。
- 为了规整指令格式，使指令具有相同的长度，规定只有 Load/Store 指令才能访问内存。
- 而运算指令不能直接访问内存，只能从寄存器取数进行运算，运算的结果也只能送到寄存器。因为寄存器编号较短，而主存地址位数较长，通过某种方式可使运算指令和访存指令的长度一致。
- 这种装入/存储型风格的指令系统的最大特点是，指令格式规整，指令长度一致，一般为 32 位。由于只有 Load/Store 指令オ能访问内存，程序中可能会包含许多装入指令和存储指令，与ー般通用寄存器型指令风格相比，其程序长度会更长。

![img](https://img-blog.csdnimg.cn/20210119195152802.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

# 第五章 中央处理器 CPU

## 【复习提示】

中央处理器是计算机的中心，也是本书的难点。其中，数据通路的分析、指令执行阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题。而关于各种寄存器的特点、指令执行的各种周期与特点、控制器的相关概念、流水线的相关概念也极易出选择题。

在学习本章时，请读者思考以下问题

- 1)CPU 分为哪几部分？分别实现什么功能？
- 2)指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？
- 3)什么是指令周期、机器周期和时钟周期？它们之间有何关系？
- 4)指令周期是否有一个固定值？为什么？
- 5)什么是微指令？它和第 4 章谈到的指令有什么关系？
- 6)什么是指令流水线？指令流水线相对于传统计算机体系结构的优势是什么？如何计算指令流水线的加速比？

请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。 ![img](https://img-blog.csdnimg.cn/20210119105804227.png?type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

> - 思考：计算机如何解决某个具体问题？
>   - 编写程序并存储 → 调入主存 → 运行程序
> - 程序是一个**指令序列** ，通过每条指令告诉计算机，执行什么操作，到哪里找操作数，操作结果送到哪里？
> - 通常，程序 首先被存放在**辅助存储器**(硬盘)中，运行时，由**操作系统**把程序装入主存，并将程序第一条指令在内存中的地址( 首地址) 送 <font color='#66ccff'>PC</font>, CPU 按照 PC 中的指令地址， 自动完成 ① 取出指令和 ② 执行指令的任务。
> - <font color='#66ccff'>中央处理器(CPU)</font> 是机器指令的解释和执行机构，是计算机的核心部件

## 5.1 CPU 的功能和基本构造

### 5.1.1 CPU 的基本功能

<img src="https://img-blog.csdnimg.cn/20210119105931494.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

- CPU 的功能:
  1. <font color='#66ccff'>指令控制</font>：完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
  2. <font color='#66ccff'>操作控制</font>：一条指令的功能往往是由若干操作信号的组合来实现的。CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
  3. <font color='#66ccff'>时间控制</font>：对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。
  4. <font color='#66ccff'>数据加工</font>：对数据进行算术和逻辑运算。
  5. <font color='#66ccff'>中断处理</font>：对计算机运行过程中出现的异常情况和特殊请求进行处理。

<img src="https://img-blog.csdnimg.cn/20210119110230138.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 50%;" />

### 5.1.2 CPU 的基本结构

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230421103246215.png" alt="image-20230421103246215" style="zoom: 33%;" />

> CPU 的基本组成: 运算器, 控制器, Cache

#### 1.运算器

- <font color='#66ccff'>运算器</font> : 实现数据的算术与逻辑运算

- 运算器部件

  - 算术逻辑单元 ALU

  - 累加寄存器 ACC

  - 程序字状态寄存器 PSW

  - 计数器 CT

  - 暂存寄存器

    - 通用寄存器组

      - 通用寄存器供用户自由编程，可以存放数据和地址。
      - 指令寄存器是专门用于存放指令的专用寄存器，不能由通用寄存器代替

    - 移位器

#### 2.控制器

- <font color='#66ccff'>控制器</font> : 产生控制信号, 协调和指挥各个部件完成执行指令的操作
  - 取指令，并指出下条指令的地址；<PC&IR>
  - 对指令译码或测试，并产生相应的操作控制信号；<CU&时序电路操作控制器>
  - 指挥并控制 CPU 、存储器和 I/O 设备之间数据流动的方向。
- 控制器部件

  - 程序计数器 PC:存放下一条指令在主存中的地址，具有自增功能。

  - 指令寄存器 IR：存放当前正在执行的指令。

  - 指令译码器

  - 存储器地址寄存器 MAR

  - 存储器数据寄存器 MDR

  - 时序系统

  - 微操作信号发生器

> 条件转移指令执行时，需要对<font color="blur" size="4">标志寄存器</font>的内容进行测试，判断是否满足转移条件。<font size="4">转移指令时，需要判断转移是否成功</font>，若成功则 PC 修改为转移指令的目标地址，否则下一条指令的地址仍然为 PC 自增后的地址。
>
> 指令包括操作码字段和地址码字段，但指令译码器仅对操作码字段进行译码，借以确定指令的操作功能。

> 注意：CPU 内部寄存器大致可分为两类：一类是<font color="blur" size="4">用户可见的寄存器</font>，可对这类寄存器编程，如<font color="blur" size="4">通用寄存器组、程序状态字寄存器</font>；另一类是<font color="blur" size="4">用户不可见的寄存器</font>，对用户是透明的，不可对这类寄存器编程，如<font color="blur" size="4">存储器地址寄存器 MAR、存储器数据寄存器 MDR、指令寄存器 IR</font>。

#### 3.Cache

Cache 存储指令和数据

### 5.1.3 CPU 中的部件功能

1. 控制器的主要寄存器
   - <font color='#66ccff'>指令寄存器 (IR Instruction Register)</font> ：存储当前正在执行的指令字 <font color='orange'>(第四章 指令系统)</font>
     - IR 中操作码字段输出送往指令译码器
     - <font color='#66ccff'>指令译码器</font>： 分析测试指令的操作码的功能。
   - <font color='#66ccff'>程序计数器 (PC Program Counter)</font> ：存储下一条要**执行指令的地址** 。
     - 顺序执行: PC+1 → PC (计数功能)
     - 转移执行: (指令中的 A) → PC (寄存功能)
   - <font color='#66ccff'>地址寄存器 (AR Address Register)</font> ：存储当前访问**数据的地址**
2. 运算器的主要寄存器
   - 数据缓冲寄存器 DR
     - 暂时存运算结果及内部缓冲；
     - 缓冲 CPU 与外部（主存与外设）数据传送。
   - 通用寄存器 (R0~R3)：存储参与运算及运算结果的 数据 。
     - CPU 中的通用寄存器可多达 16 个， 32 个，甚至更多；
   - 状态字寄存器(PSW)：保存 运算状态 和 条件控制信号
     - 进位标志 (C)，溢出标志 (V)，零标志 (Z)，符号标志 (N)
     - 每个信号由一个触发器保存，从而拼成一个寄存器。
3. 操作控制器与时序产生器
   - <font color='#66ccff'>数据通路</font>： 许多寄存器之间 传送信息的通路
   - <font color='#66ccff'>操作控制器</font>： 根据**指令操作码**和**时序信号**， 产生各种控制信号, 在各寄存器之间建立数据通路 。
   - 根据设计方法不同，操作控制器可分为
     1. <font color='#66ccff'>硬布线控制器</font>：<font color='orange'>(纯硬件)</font>采用时序逻辑技术实现；
     2. <font color='#66ccff'>微程序控制器</font>： 采用存储逻辑实现；
     3. 前两种方式的结合: 简单,常用指令使用硬布线; 复杂指令使用微程序
   - <font color='#66ccff'>时序产生器</font>： 产生定时信号 对各种操作信号 实施时间上的控制
   - 此外，CPU 中还包括中断系统、总线接口等等。
4. 控制器工作流程概述
   1. 程序事先编制好，存入主存。
   2. 当要运行该程序时，将其调入 Cache 将**程序的起始地址**（第一条指令所在内存单元的地址）送入 PC
   3. 根据 PC 的值，取出一条指令， **送入 IR**
   4. CPU 自动修改 PC 的值 （顺序方式下 PC+1 -->PC)
   5. 对 IR 中的指令进行译码（分析 OP)
   6. 在 时序电路的控制 下，在适当的时刻给相关部件 发出控制信号 。（必要时，修改 PC 的值）
   7. 若程序未终止则返回 `step3`

## 5.2 指令执行过程 ★

<img src="https://img-blog.csdnimg.cn/20210119124234452.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 50%;" />

> CPU 的工作就是 周而复始的执行指令 过程。

- 指令的分段执行过程

  1. 取指令： 根据 PC 提供的地址从主存 /cache 中读取当前指令，送到指令寄存器 IR 中；

  2. 分析指令： 通过译码电路分析 IR 中指令操作码字段表示什么操作，并在时序系统的配合下产生该指令对应的微操作命令序列；

  3. 执行指令： 执行阶段还可细分为

     1. 取操作数
     2. 执行操作
     3. 形成下一条指令地址

     - 在运行的过程中，CPU 还要对出现的某些 异常情况 或 输入 输出请求 进行处理

### 5.2.1 指令周期

- <font color='#66ccff'>指令周期</font>： CPU 从内存取出一条指令并执行这条指令的所有操作时间总和 。

  - 一个指令周期 又可细分成 若干个 CPU 周期

- <font color='#66ccff'>CPU 周期</font>： 又称机器周期(机器指令周期)，一般用 从内存读取一条指令字 的最短时间来定义。

  - 一个 CPU 周期 又包含 若干时钟周期

- <font color='#66ccff'>时钟周期</font>： CPU 处理操作的**基本时间单位**，通常称为 <font color='#66ccff'>节拍脉冲</font> 或 <font color='#66ccff'>T 周期</font>

  - CPU 中最小的时间单位

- 基本指令周期： **取指周期<font color='orange'>(取指令)</font>+执行周期<font color='orange'>(执行指令)</font>**
  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230421111442919.png" alt="image-20230421111442919" style="zoom: 33%;" />

  - > 执行一条指令最少需要几个 CPU 周期？

    - 每条指令至少为一个指令字长，读取 译码至少需要一个 CPU 周期
    - 执行指令的具体动作，至少需要一个 CPU 周期
    - 执行任意一条指令至少需要 2 个 CPU 周期

- 拓展—关于指令周期
  - 一个完整的指令周期由 若干机器周期组成
    - 取指周期 → 间址周期 → 执行周期 → 中断周期
    - 所有指令的 第一个机器周期必为取指周期
    - 一个基本的 CPU 周期包含 4 个时钟周期 ，对于某些 CPU 周期可以包含更多的时钟周期。
      - ==本教材上，间址周期和执行周期统称为执行周期！==
  - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230424083238541.png" alt="image-20230424083238541" style="zoom:33%;" />

### 5.2.2 典型指令的指令周期<例>

> 一个简单的程序
>
> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429200608142.png" alt="image-20230429200608142" style="zoom:50%;" />
>
> 对应的 CPU 数据通路图
>
> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429201028588.png" alt="image-20230429201028588" style="zoom: 50%;" />
>
> - 指令周期的分析应该针对某一个 CPU 数据通路进行分析, 不同的 CPU 数据通路结构的结果可能不同
> - 一个 CPU 周期 使用一次总线

1. `MOV R0 , R1`

   - 指令周期分析
     1. 读取指令阶段
        1. PC→ABUS→ 指令 Cache, 指令译码并启动
        2. 指令 Cache→IR
        3. PC→PC+1, 为去下一条指令做好准备
        4. IR 中的操作码被译或测试， CPU 识别出是指令 MOV
     2. 执行指令阶段
        1. R1→ALU, R1 中数据通过 ALU 传送
           R1 读出, ALU 传送控制
        2. ALU→DBUS→DR→R0
           ALU 输出, DR 锁存, 写入 R0
   - MOV 指令的指令周期
     - MOV 是一条 RR 型指令，它需要==两个== CPU 周期
     - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429203700326.png" alt="image-20230429203700326" style="zoom:50%;" /> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429203720244.png" alt="image-20230429203720244" style="zoom:50%;" />

2. `LAD R1, 6`

   - > 从内存取数到寄存器,（6）→ R1

   - 指令周期分析
     1. LAD 取指周期: CPU 动作与取 MOV 指令的取值周期中一样。
     2. LAD 指令的执行周期
        1. IR → **DBUS** → AR ；
           该过程为寻址周期；
        2. AR →ABUS → 数据 Cache ，译码并启动；
        3. 数据 Cache → **DBUS** → DR →R1 ；
   - LAD 指令的指令周期
     - LAD 指令是 RS 型指令, 需要访存获取操作数, 共包含==三个== CPU 周期
     - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429204451541.png" alt="image-20230429204451541" style="zoom:50%;" /> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429204515901.png" alt="image-20230429204515901" style="zoom:43%;" />

3. ADD 指令的指令周期

   - ADD 指令是 RR 型指令，指周期由==两个== CPU 周期组成
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429205042452.png" alt="image-20230429205042452" style="zoom:50%;" />

4. STO 指令的指令周期

   - `STO R2, (R3)`存寄存器数据到内存, R2→(R3)

   - STO 指令是 RS 型指令, 需要==三个== CPU 周期

     1. 取指周期

     2. 执行周期

        1. R3 →DBUS →AR ，发出地址启动数据 Cache
           该过程为间址周期；

        2. R2 →DBUS → 数据 Cache

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429205654020.png" alt="image-20230429205654020" style="zoom:50%;" />

5. JMP 指令的指令周期

   - JMP 指令是一条无条件转移指令 ，用来改变程序的执行顺序; 需要两个 CPU 周期
   - 指令周期
     1. 取指周期（略）
     2. 执行周期
     - IR →DBUS →PC
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429212111779.png" alt="image-20230429212111779" style="zoom:50%;" />

### 5.2.3 指令周期的表示方法

计算机进行设计时，用方框语言描述指令周期。

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429213803584.png" alt="image-20230429213803584" style="zoom:50%;" />

用方框图语言表示机器指令周期，一个方框代表一个 CPU 周期

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429214046482.png" alt="image-20230429214046482" style="zoom:45%;" />

#### 例题

> 例： 下图（课本图 5.15 ）所示为双总线结构机器的数据通路，各构成部件如图, 线上标注有小圈表示有控制信号，未标字符的线为直通线
> ① `ADD R2, R0`指令完成 (R0) + (R2) →R0 的功能操作， 画出其指令周期流程图并列出相应的微操作控制信号序。
> ② `SUB R1 R1, R3`指令完成 (R3) - (R1) →R3 的操作，画出 其指令期流程图并列相应的微操作控制信号序列。
>
> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429214831919.png" alt="image-20230429214831919" style="zoom:50%;" />

1. `ADD R2, R0`指令执行过程
   1. 取指过程
      <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429215401607.png" alt="image-20230429215401607" style="zoom:50%;" />
   2. 执行过程
      <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429215416156.png" alt="image-20230429215416156" style="zoom:50%;" />
2. `SUB R1, R3`指令执行过程
   - 与 ADD 指令不同之处在于 ALU 的控制信号为“－”
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429215544547.png" alt="image-20230429215544547" style="zoom: 50%;" />

## 5.3 时序产生器和控制方式

### 5.3.1 时序信号的作用和体制

1. 指令的执行过程就是依次产生一个确定的 ==控制信号序列== 的过程。

   - 指令的执行是分阶段分步骤进行的。

   - 每一步的操作是由控制器产生一些相应的控制信号实现。

   - 各步骤的操作是有先后秩序的，控制信号的长短必须有严格的时间控制。

2. 时序信号的作用：使计算机准确、迅速、有条不紊地工作
3. 时序信号基本体制： 电位—脉冲制
4. 常用控制器时序方式：
   - 硬布线控制器：采用 主状态周期 节拍电位 节拍脉冲三级体制。
   - 微程序控制器：采用 节拍电位 节拍脉冲 二级体制。

### 5.3.2 时序信号产生器

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230426103837197.png" alt="image-20230426103837197" style="zoom:50%;" />

1. 时钟源 ：产生 方波 时钟脉冲信号。
2. ① 环形脉冲发生器 ：产生一组有序的间隔相等或不等的脉冲序列 。
3. ② 节拍脉冲和读写时序电路: 产生 节拍脉冲 及存储器读写时序信号。
4. ③ 启停控制逻辑电路 ：节拍脉冲信号 使能 电路。

#### 时序产生器内部结构

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230426105343935.png" alt="image-20230426105343935" style="zoom:33%;" />

1. 产生 C1 、 C2 、 C3 、 C4
2. 产生
   - $T_1^o = C_1\cdot \overline{C_2}$
   - $T_2^o = C_2\cdot \overline{C_3}$
   - $T_3^o = \overline{\overline{C_3}}=C_3$
   - $T_4^o =\overline{C_1}$
   - $RD^o = RD \cdot C_2; WE^o = WE\cdot C_3$

### 5.3.3 控制方式

> <font color='#66ccff'>控制方式</font>即控制不同操作序列 时序信号的方法。

1. <font color='#66ccff'>同步控制方式</font>: 指令在执行时所需的机器周期数 (CPU 周期）和时钟周期数（节拍脉冲）都固定不变。
   - 采用完全统一的机器周期执行各种不同的指令。
   - 采用不定长机器周期。
   - 中央控制与局部控制结合。
2. <font color='#66ccff'>异步控制方式</font>: 指每个操作控制信号根据需要确定完成时间。
   - 根据“应答”方式操作。
3. <font color='#66ccff'>联合控制方式</font>: 同步控制和异步控制相结合的方式。
   - 大部分操作序列安排在**固定的机器周期**中，部分采用“回答”信号方式；
   - 机器周期的节拍脉冲数固定，但是各条指令周期的机器周期数不固定。

## 5.4 微程序控制器 ★

### 5.4.1 微程序控制原理

概述: 微程序&微指令

- 将**1 个 cpu 周期内**要发出的**控制信号**编成<font color='#66ccff'>微指令</font>，这样每条机器指令的所有操作可以编成一段由微指令组成的<font color='#66ccff'>微程序</font>
- 将所有机器指令的微程序存到一个只读存储器—<font color='#66ccff'>控制存储器(CM)</font>里
  - CPU 执行一条指令时，只需将 CM 中相应的一段微程序读出来，执行该段微程序，就可产生各种微操作信号，以实现该指令的功能
- 微程序设计技术是利用==软件方法来设计硬件== 的一门技术。具有 规整性、灵活性、可维护性 等一系列优点；

#### 一.基本术语

- <font color='#66ccff'>微命令</font>: 控制部件 通过控制线向执行部件发出的 各种**控制信号** 。
- <font color='#66ccff'>微操作</font>： 执行部件 接受微命令后所进行的操作 。
  - **相斥性**微操作：不能同时或在同一个 CPU 周期中出现的微操作。
  - **相容性**微操作：能同时或在同一个 CPU 周期中出现的操作。
- <font color='#66ccff'>微指令 μI</font>: 在机器的 一个 CPU 周期中 ，一组实现一定操作功能的**微命令的组合**
- <font color='#66ccff'>微程序</font>: 实现一条机器指令功能的许多条微指令组成的序列。
- <font color='#66ccff'>状态测试</font>: 执行部件 通过反馈线向控制部件反映当前 操作状态信息，以使控制部件决定下一步的微命令

#### 二.微指令格式

- 微指令: 在一个 CPU 周期中，一组实现一定操作功能的微命令的组合。

  - <font color='#66ccff'>操作控制字段</font>: 产生 控制信号
  - <font color='#66ccff'>顺序控制字段</font>: 产生 下条微指令的地址
  - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230428101352482.png" alt="image-20230428101352482" style="zoom: 33%;" />

- 顺序控制字段

  - 前 2 位(18,19) P1、P2：测试标志
    1. 当测试位为 00, 则<font color='#66ccff'>顺序寻址微指令 </font>
       - 由 20~23 直接指示后继地址；
    2. 任意测试位为 1, 则<font color='#66ccff'>跳跃寻址微指令 </font>
       - 说明要进行相应**测试**，根据测试结果对 20~23 的某几位进行修改，最终形成后继地址
  - 后 4 位(20~23)：直接地址 μAR
  - `顺序控制字段=P字段(测试字段)+μAR`

- 思考：如何从节拍电位信号生成节拍脉冲信号？
  - 微指令给出的控制信号都是**节拍电位**信号
    部分微命令还要和时序电路产生的脉冲信号相与

#### 三.微程序控制器组成原理

- ①<font color='#66ccff'>控制存储器 CM</font>: 用于存放实现**全部**指令系统的微程序
- ②<font color='#66ccff'>微指令寄存器 μIR</font>: 用来存放**当前**执行的一条微指令 <font color='orange'>(分段存放)</font>
  - 微命令寄存器: 存放 P 字段+操作控制字段
  - 微地址寄存器 μAR: 顺序控制字段
- ③<font color='#66ccff'>地址转移逻辑</font>: 用于形成下条微指令的**微地址**
- <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230430185932949.png" alt="image-20230430185932949" style="zoom:33%;" />

#### 四.微程序实例—十进制加法

> “十进制加法” ADD 指令是 用 BCD 码来完成十进制数的加法运算
>
> - 当 两数位相加小于等于 9 时，结果正确；
> - 当 两数位相加大于 9 时，必须对和数位进行加 6 的修正。
> - 例如
>   - 3+4 = 0011 + 0100 = 0111= 7
>   - 8+7 = 1000 + 0111 = 1111 <font color='#EE0000'>+ 0110(修正) = 0001 0101= 15</font>
>   - 25+36 = 0010 0101 + 0011 0110=0101 1011<font color='#EE0000'>+0110(修正)=0110 0001</font>
>
> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230429223444163.png" alt="image-20230429223444163" style="zoom:33%;" />

① 指令功能： 用 BCD 码来完成十进制的加法运算。 R1+R2→R2

② 处理器部件

③ 指令流程

④ 微命令信号
<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230430191108806.png" alt="image-20230430191108806" style="zoom:33%;" /> 左边是对应的微命令信号

⑤ 微指令格式

⑥ 微指令编码

#### 五.CPU 周期与微指令周期的关系

- 微指令周期=**读出**微指令的时间 + **执行**该条微指令的时间
- 例如，CPU 周期为 0.8us ，包括 4 个节拍脉冲 T1~T4 ，每个脉冲 200ns
  - T1~T3 的 600ns 为执行微指令的时间；
  - T4 的 200ns 为取微指令的时间；
  - T1 的上升沿，将读出的微指令存入微指令寄存器；
  - T4 的上升沿保存微指令的执行结果， T4 期间取微指令
  - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230430194816783.png" alt="image-20230430194816783" style="zoom: 33%;" />

#### 六.机器指令 VS 微指令

- 一条机器指令对应一个微程序，一个微程序由若干条微指令序列组成的
- 一条机器指令的功能是由若干条微指令组成的序列来实现的
- 机器指令存储在内存中， CPU 外部；微指令存储在 CM 中，属于 CPU 内部
- 每一个 CPU 周期对应一条微指令

### 5.4.2 微程序设计技术

#### 一.微命令编码方式

> - 如何有效缩短微指令字长
> - 如何有利于缩短微程序 ，减少所需的控存空间
> - 如何有利于提高微程序执行速度

1. 微命令编码方式: 主要指 操作控制字段 的编码表示方法
2. <font color='#66ccff'>直接表示法</font>： 将控制字段的 每个二进制位 定义为 一个微命令
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230430205730563.png" alt="image-20230430205730563" style="zoom:33%;" />
   - 优点: 简单直观，其输出可直接用于控制，执行速度快，操作并行性好
   - 缺点: 微指令字较长，因而使控制存储器容量较大
3. <font color='#66ccff'>编码表示法</font>: 将微指令操作控制字段划分为 若干个子字段
   - 把==相斥的微命令== 划分在同一个字段中，相容的微命令划分在不同字段；<font color='orange'>(节约编码)</font>
     对每个子字段的所有微命令进行统一编码，不同编码表示不同的微命令；
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230430210936123.png" alt="image-20230430210936123" style="zoom:33%;" /> 三个微命令互斥, 只有一个可以为 0, 则可以编码为 2 位子字段
   - 优点: 可大大缩短微指令字长，缩小 CM 的容量
   - 缺点: 需要微命令译码，故微程序的执行速度稍稍减慢。

#### 二. 微地址的形成

1. 相关术语

   - 微程序的<font color='#66ccff'>入口地址</font>

     - 微程序的第一条微指令所在控存单元的地址；

     - <font color='#66ccff'>现行微指令</font>
       - 执行微程序过程中，当前正在执行的微指令；
       - 现行微指令的地址称为现行微地址。

   - <font color='#66ccff'>后继微指令</font>
     - 现行微指令执行完毕后，下一条要执行的微指令；
       - 后继微指令的地址称为后继微地址。

2. 微地址形成方法

   1. <font color='#66ccff'>计数器方式（增量方式）</font>: **顺序执行**时，后继地址在现行微地址上**加上一增量**; **非顺序执行**时，需执行一条转移微指令 。
      - 优点：顺序控制字段较短，设计简单。
      - 缺点：多路并行转移弱，速度较慢，灵活性差。
   2. <font color='#66ccff'>多路转移方式（断定）</font>：将顺序控制字段分成<font color='#66ccff'>测试字段 (P) </font>和<font color='#66ccff'>下地址字段</font>。 未出现多路分支时， 后继由**下地址字段**直接给出； 出现多路分支时，根据**测试字段值和状态条件**选择转移地址。
      - 优点：多路转移灵活，速度快；
      - 缺点：转移地址硬件设计复杂。
   3. 当采用多路转移方式（断定方式）应注意

      - 直接地址字段的长度要保证在未出现多路分支时， 寻址范围能覆盖整个控制存储器(CM)
      - 出现多路分支时，转移地址由微地址转移逻辑产生。
        微地址转移逻辑的输入来源一般包括：
        <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230520225838740.png" alt="image-20230520225838740" style="zoom:50%;" />
      - 当微地址转移逻辑要进行测试时, 一般地，对 n 位的状态标志(或是操作码)进行某一种测试 P, 最终会相应地对 uAR 中的 n 位进行修改 ，则最多可产生 2^n^种分支地址 。

   4. > 已知某计算机采用微程序控制方式，其控存容量为 512 × 32 位，微程序可以在控存中实现转移，可控制微程序转移的条件有 6 个，采用直接编码方式，后继微指令地址采用多路转移方式。
      >
      > 微指令字长 32 位，格式如下，请说明微指令中 3 个字段分别应为多少位。<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230521231511892.png" alt="image-20230521231511892" style="zoom:50%;" />

      - 由控存单元数可知共 512 个，则每个控存单元地址位为 9 位(2^9^=512)，则微指令中的后继微指令地址(下址)位数为 9 位；
      - 可控制微程序转移的条件为 6 个，且按照直接控制编码，则测试条件位数为 6 位；
      - 剩下的为操作控制字段可用位数 32-9-6=17 位

#### 三. 微指令的格式

1. 水平型微指令: 在一个微指令周期内， 同时**给出多个能并行操作的微命令**
   - 全水平型
   - 字段译码型
   - 混合型
2. 垂直型微指令: 在微指令中设置**微操作码字段和地址码字段**，采用微操作码编译法，并由微操作码规定微指令的功能

#### 四. 动态微程序设计

1. 静态微程序设计：微程序设计好后，不再（能）修改
2. 动态微程序设计：微程序可根据需要再修改

> #### 微程序设计流程总结：
>
> 1. 确定机器的指令系统
> 2. 确定数据通路结构
> 3. 分析每条指令 ，画出整个指令系统的 CPU 周期流程图
> 4. 列明每条**微指令**对应发出的**微命令**
> 5. 确定微指令的格式（包括微命令、微地址形成方式）
> 6. 给每条**微指令**分配好在**CM 中的存储单元地址**
> 7. 根据 4 和微命令格式确定**操作控制字段** ；根据 6 和微地址形成方式确定**顺序控制字段**

## 5.5 硬连线控制器

> 引入: 微程序控制器采用软件方法, 执行时间略长
>
> → 采用硬件方法, 将控制部件看作专门产生固定时序信号的逻辑电路 (硬连线控制器)

1. 硬连线控制器: 使用门电路和触发器构成的逻辑电路来产生控制信号
   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230522002532280.png" alt="image-20230522002532280" style="zoom: 45%;" />
2. 硬连线控制器输入包括：

   - 指令译码器输出结果
   - 执行部件反馈信息
   - 时序信号
     - 节拍电位(M)
     - 节拍脉冲(T, 即平时常说的 T1T2T3)

3. 设计方法： 根据 所有机器指令流程图 ，寻找 产生同一个微操作信号的所有条件, 并与适当的节拍电位和节拍脉冲组合 ，然后用布尔代数表达式描述，最后用门电路来实现。

   - 优点：速度快
   - 缺点：设计复杂、不易修改

4. > M1 M2 M3 为节拍电位信号， T1 T2 T3 T4 为一个 CPU 周期的节拍脉冲信号， MOV LAD ADD STO JMP 分别表示对应机器指令的 OP 操作码译码输出信号。写存储器安排在 T2 ，写寄存器安排在 T3 进行，读取指令在 T4 进行。
   >
   > <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230522091314735.png" alt="image-20230522091314735" style="zoom: 40%;" />
   >
   > 参照上图，试分析硬连线控制器中 LDIR 、 LDDR 的逻辑表达式

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230524000145855.png" alt="image-20230524000145855" style="zoom: 33%;" />

## 5.6 提高 CPU 性能的技术

### 5.6.1 流水 CPU 技术

1. 并行处理技术
   - <font color='#66ccff'>同时性</font>: 指两个以上事件在**同一时刻**发生；<font color='orange'>(严格的并行)</font>
   - <font color='#66ccff'>并发性</font>: 指两个以上事件在**同一时间间隔**内发生。<font color='orange'>(交替进行)</font>
2. 计算机并行处理技术形式：
   - 时间并行 ：指时间重叠。
   - 空间并行 ：指资源重复。
   - 时间并行+空间：指时间重叠和资源重复的综合应用 。例如，奔腾 CPU 采用了超标量流水技术。
3. 流水线技术设计方法：将一个大的功能部件==分成几个独立的功能部件== ，并行工作以提高执行速度的技术。
4. 流水线中功能部件必须满足的条件：
   - 流水线中的任务是连续的，流水线应是充满的。<font color='orange'>(流水线启动耗时)</font>
   - 分解的任务是有联系的。
   - 段与段之间传送字任务时，必须通过高速缓冲寄存器。
   - 流水线中各段的执行时间应尽可能相等。

### 5.6.2 流水 CPU 的结构

#### 一. 流水计算机的系统组成

1. 组成

   - 指令部件

   - 指令队列

   - 执行部件

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230524001638625.png" alt="image-20230524001638625" style="zoom:33%;" />

2. 假设指令周期包含 4 个子过程: 取指, 译码, 取操作数, 运算并存储结果

   - 顺序方式的串行指令执行过程
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230524002850873.png" alt="image-20230524002850873" style="zoom:33%;" />
   - 并行方式的指令执行过程
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230524002902520.png" alt="image-20230524002902520" style="zoom:33%;" />

#### 二. 流水 CPU 的时空图

| <font color='#66ccff'>非流水线</font>时空图                                                                 | <font color='#66ccff'>标量流水线</font>时空图                                                               | <font color='#66ccff'>超标量流水线</font>时空图                                                                                           |
| ----------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| ![image-20230524003032021](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230524003032021.png) | ![image-20230524003042748](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230524003042748.png) | ![image-20230524003052220](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230524003052220.png)<br>线程多, 能同时执行两个过程 |

#### 三. 流水线的性能

1. <font color='#66ccff'>吞吐率</font>: 单位时间内流水线所**完成指令**或**输出结果**的数量

   - 设 m 段的流水线 各段时间为 Δt 则
   - $\textcolor{#66ccff}{最大吞吐率T_{pmax}=\frac1{\Delta t}}$ <font color='orange'>可以忽略第一个任务的启动时间</font>
   - $实际吞吐率T_p=\frac{完成的任务数n}{完成n个任务的时间}$
   - $\textcolor{#66ccff}{连续处理n条指令的吞吐率T_p=\frac{n}{m\cdot\Delta t+(n-1)\cdot \Delta t} }$
     $m\Delta t:开始段(第一个任务)的时间;\quad (n-1)\Delta t:之后n-1个任务的时间$

2. <font color='#66ccff'>加速比$S_p$</font>: m 段的流水线的速度与等功能的非流水线速度之比

   - 设流水线各段时间为 Δt
   - 则完成 n 条指令在 m 段流水线上共需要$m\cdot\Delta t+(n-1)\cdot \Delta t$
     完成 n 条指令在等效的非流水线上共需要$T'=nm\cdot \Delta t$
   - 则$\textcolor{#66ccff}{S_p}=\frac{nm\cdot \Delta t}{m\cdot\Delta t+(n-1)\cdot \Delta t}=\textcolor{#66ccff}{\frac{nm}{m+n-1}}$

3. 效率: 流水线中各功能段的==利用率==

   - 由于流水线有**建立时间**和**排空时间**, 因此各功能段的设备不可能一直处于工作状态
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230524235614673.png" alt="image-20230524235614673" style="zoom:33%;" />
   - $效率=\frac{流水线各段处于工作时间的时空区}{流水线中各段总的时空区}=\frac{mn\Delta t}{m(m+n-1)\Delta t}=\frac{n}{m+n-1}$

4. > 例: 指令流水线有取指(IF) 、译码(ID) 、执行(EX) 、访存(MEM)、写回寄存器堆(WB)五个过程段，共有 7 条指令连续输入此流水线，时钟周期为 100ns 。

   1. 求流水线的实际吞吐率（单位时间里执行完毕的指令数)
      - 流水线执行完 7 条指令的时间是 5+(7-1)=11 个时钟周期 <font color='orange'>(第一条指令 5 个周期, 剩下的因为流水线, 只需要 1 个周期)</font>
      - 实际吞吐率为$7 / (11× 100ns) ≈64 × 10^5 条指令/s$
   2. 求流水处理器的加速比。

      - $C_k=7\times5 / 11≈3.18$

### 5.6.3 流水线的问题

#### 资源相关

- <font color='#66ccff'>资源相关</font>: 多条指令进入流水线后在同一机器时钟周期内 **争用同一个功能部件** 所发生的冲突

  - 如 取指令和取操作数两个环节都需要访问存储器,冲突

- <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230526164829020.png" alt="image-20230526164829020" style="zoom: 33%;" /> 
  第1 、 2 条指令的 MEM 与第 4 、 5 条指令的 IF ，都需要访存若数据与指令在同一存储器中，且单端口访问，则争用资源
- 解决方法:
  1. 第 4 条指令推迟一个时钟周期；
  2. 将数据与指令存储器分离；或采用双端口存储器；

#### 数据相关

- <font color='#66ccff'>数据相关</font>: 必须等前一条指令执行完毕后，才能执行后一条指令

- 某程序段如图 <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230526165905023.png" alt="image-20230526165905023" style="zoom: 40%;" />

  以上 3 条指令的流水执行如下
  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230526170115381.png" alt="image-20230526170115381" style="zoom:40%;" /> (IF:取指 ID: 译码 EX: 执行 MEM: 访问内存 WB: 写寄存器堆)

  - 正常: ADD 得到 R1, R1-R5 → 实际: R1 还未计算出结果, SUB 指令将 R1 读出用于下一步计算

- 三种数据相关问题

  - 写后读相关(RAW): 指令 j 试图在指令 i 写入寄存器前就读出该寄存器的内容，这样，指令 j 就会错误地读出该寄存器中的旧内容。
    - `MUL R1,R2; ADD R3,R1;` ADD 在 MUL 得出结果,**写**入 R1 之前, 就**读**出 R1 内容, 进行 ADD 运算
    - 正确的情况应该是 先==写 R1 后读 R1==
  - 读后写相关(WAR): 指令 j 试图在指令 i 读出寄存器之前就写入该寄存器，这样，指令 i 就错误地读出该寄存器中的新内容。
    - `MUL R1,R2; MOV R2,0;` MOV 在 MUL**读**出 R2 内容前, 就向 R2**写**入了 0
  - 写后写相关(WAW): 指令 j 试图在指令 i 写入寄存器之前就写入该寄存器，这样，两次写操作的先后次序被颠倒，就会错误的使指令 i 写入的值成为该寄存器的内容。
    - `MUL R1,R2; MOV R1,0;` MUL 写入 R1 过程慢于 MOV, MOV 结果被覆盖

- 解决方法

  1. 停顿流水线
  2. 采用定向技术（旁路技术或相关通路技术）
  3. 增设运算结果缓冲寄存器

#### 控制相关

- <font color='#66ccff'>控制相关</font>: 当执行**转移指令**时，使流水线发生**断流**的问题
  - 如 1 指令最后一环跳转到 4,此时指令 23 已经进入流水线,但实际上 23 不需要执行
- 解决方法
  1. 延迟转移法 (气泡)
  2. 转移预测法 (Predict PC)
  3. 加快和提高形成条件码 (旁路 / 专用计算单元)
  4. 加快短循环程序的处理
  5. 采用优化延迟转移技术
  6.

### 5.6.4 其他提高 CPU 性能方法

1. 主要方法
   - 改进芯片 ：与微电子技术发展密切相关
   - 改进系统结构
2. RISC(Reduced InstrucTIon Set Computer)技术 ：为提高指令运行速度，简化指令的技术。

   - RISC 特点：

     - 使用等长指令；
     - 寻址方式少，没有存储器间接寻址方式；
     - 只有取数和存数指令访问存储器，没有 SS 型指令；
     - 指令功能简单，控制器多以硬布线为主；
     - 大部分指令在一个处理周期内完成，支持指令流水线技术。
     - CPU 中通用寄存器较多，且优化使用。
     - 采用优化的编译程序，可以有效支持高级语言程序。

3. MMX 技术 ：把各种不同的电子媒质集成起来，统一进行存储、处理和传输的扩展结构技术。新增了专用的数据类型、寄存器和指令
   - 采用 SIMD （单指令多数据处理）型指令。
   - 具有“饱和”运算功能。
   - 具有“积和”运算的能力。
   - 具有比较指令。
   - 具有转换指令。
4. 动态执行技术 ：通过预测程序流来调整指令的执行并且分析程序的数据流来选择指令执行的最佳顺序。

## 5.7 本章开头提出的问题回答

1. CPU 分为哪几部分？分别实现什么功能？

   - CPU 分为运算器和控制器。
   - 其中运算器主要负责数据的加工，即对数据进行算术和逻辑运算
   - 控制器是整个系统的指挥中枢，对整个计算机系统进行有效的控制，包括指令控制、操作控制、时间控制和中断处理。

2. 指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？

   - 从时间上讲，取指令事件发生在“取指周期”，取数据事件发生在“执行周期”。
   - 从空间上讲，从内存读出的指令流流向控制器（指令寄存器），从内存读出的数据流流向运算器（通用寄存器）。

3. 什么是指令周期、机器周期和时钟周期？它们之间有何关系？

   - CPU 每取出并执行一条指令所需的全部时间称为指令周期；
   - 机器周期是在同步控制的机器中，执行指令周期中一步相对完整的操作（指令步）所需的时间，通常安排机器周期长度=主存周期；
   - 时钟周期是指计算机主时钟的周期时间，它是计算机运行时最基本的时序单位，对应完成一个微操作所需的时间，通常时钟周期=计算机主频的倒数

4. 指令周期是否有一个固定值？为什么？

   - 由于计算机中各种指令执行所需的时间差异很大，因此为了提高 CPU 的运行效率，即使在同步控制的机器中，不同指令的指令周期长度都是不一致的，即指令周期对不同的指令来说不是个固定值。

5. 什么是微指令？它和第 4 章(指令系统)谈到的指令有什么关系？

   - 控制部件通过控制线向执行部件发出各种控制命令，通常把这种控制命令称为<font color='#66ccff'>微命令</font>
     而一组实现一定操作功能的微命令的组合，构成一条<font color='#66ccff'>微指令</font>。
     许多条微指令组成的序列构成<font color='#66ccff'>微程序</font>，微程序完成对指令的解释执行。
   - 指令，即指机器指令。每条指令可以完成一个独立的算术运算或逻辑运算操作。
   - 在采用微程序控制器的 CPU 中，一条指令对应一个微程序，一个微程序由许多微指令构成，一条微指令会发出很多不同的微命令。

6. 什么是指令流水线？指令流水线相对于传统计算机体系结构的优势是什么？如何计算指令流水线的加速比？
   - 指令流水线是把指令分解为若干子过程，通过将每个子过程与其他子过程并行执行，来提高计算机的吞吐率的技术。
   - 采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种并行处理技术，通过在同一个时间段使用各功能部件，使得利用率明显提高。
   - 流水线的加速比指的是完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。一条 k 段流水线理论上的最大加速比为 Smax=k。因此，在现代计算机中提高流水线段数有利于提高计算机的吞吐量。具体的加速比要使用时空图来计算。

## 5.8 常见问题

1. 流水线越多，并行度就越高。是否流水段越多，指令执行越快？

   - 错误，原因如下：
     1. 流水段缓冲之间的额外开销增大。每个流水段有一些额外开销用于缓冲间传送数据、进行各种准备和发送等功能，这些开销加长了一条指令的整个执行时间，当指令间逻辑上相互依赖时，开销更大。
     2. 流水段间控制逻辑变多、变复杂。用于流水线优化和存储器（或寄存器）冲突处理的控制逻辑将随流水段的增加而大增，这可能导致用于流水段之间控制的逻辑比段本身的控制逻辑更复杂。

2. 有关指令相关、数据相关的几个概念
   1. 两条连续的指令读取相同的寄存器时，会产生读后读( Read After Read,RAR)相关，这种相关不会影响流水线。
   2. 某条指令要读取上一条指令所写入的寄存器时，会产生写后读( Read After Write,RAW)相关，它称数据相关或真相关，影响流水线。按序流动的流水线只可能出现 RAW 相关。
   3. 某条指令的上条指令要读/写该指令的输出寄存器时，会产生读后写（ Write After Read,WAR)和写后写( Write After Write,WAW)相关。
   4. 在非按序流动的流水线中，既可能发生 RAW 相关，又可能发生 WAR 相关和 WAW 相关。 **对流水线影响最严重的指令相关是数据相关。**

# 第六章 总线系统

![img](https://img-blog.csdnimg.cn/20210119200448840.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

## 【复习提示】

本章的知识点较少，其中总线仲裁及总线操作和定时方式是难点。本章内容通常以选择题的形式出现，特别是系统总线的特点、性能指标、各种仲裁方式的特点、异步定时方式及常见的总线标准和特点等。总线带宽的计算也可能结合其他章节出综合题

在学习本章时，请读者思考以下问题：

- 1)引入总线结构有什么好处？
- 2)引入总线结构会导致什么问题？如何解决？

请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。 ![img](https://img-blog.csdnimg.cn/2021012008075435.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

## 6.1 总线的概述和结构形态

### 6.1.1 总线基本概念

1. <font color='#66ccff'>总线</font>: 构成计算机系统的互联机构，是 系统内各功能部件之间进行==信息传送== 的公共通路 。
2. 总线的特点: 某一时刻只能有一路信息在总线上传输， 即==分时共享==

![img](https://img-blog.csdnimg.cn/20210120081324146.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

3. 按传送信息分类的总线

   - 地址总线
     - 单向 ，用于传送 地址信息
     - 其位数决定可直接寻址的范围；
   - 数据总线
     - 双向 ，用于传送 数据信息
     - 其位数有 8 位、 16 位、 32 位、 64 位等；
   - 控制总线
     - 传送控制、状态信息；
     - 其类型决定计算机的特色；位数不定。

4. 总线可分为以下几类（教材上的分类）：
   - 内部总线 CPU 内部连接各寄存器及运算器部件之间的总线。
   - 系统总线 ：外部总线。 CPU 和计算机系统中其他高速功能部件相互连接的总线。
   - I/O 总线 ：中低速 I/O 设备相互连接的总线。

#### 总线的特性

- 物理特性: 总线的位数，总线插头、插座的形状，引脚的排列方式等；
- 功能特性: 每根线的功能。 确定每一根总线的名称、定义、功能与逻辑关系等，如传送数据、地址信号、中断信号、 DMA 控制信号等；
- 电气特性: 规定每一根总线上信号的传送方向及有效电平范围等内容；；一般规定送入 CPU 的信号叫输入信号（ IN ），从 CPU 发出的信号（ OUT ）。
- 时间特性: 总线上各信号有效的时序关系；

1. 机械特性：尺寸、形状、管脚数、排列顺序
2. 电气特性：传输方向和有效的电平范围
3. 功能特性：每根传输线的功能(地址、数据、控制)
4. 时间特性：信号的时序关系

#### 总线标准

1. 总线的标准化
   - 为保证总线的性能充分发挥以及兼容问题而提出的；
   - 主要包括总线的各种特性、数据传输率、总线通信协议、仲裁协议等一系列规定和约定。
2. 总线标准的来源
   - 权威组织正式公布的标准；
   - 实际存在的工业标准；
3. 典型的标准总线: ISA 、 EISA 、 PCI 等；
4. 按总线标准设计的接口是 <font color='#66ccff'>通用接口</font>

#### 总线的性能指标

1. <font color='#66ccff'>总线宽度</font>: 一次总线操作中，最多可传送的数据位数。
2. <font color='#66ccff'>总线周期</font>: 一次总线操作所需要的最小间隔时间。
   - 总线周期与总线的时钟频率成反比，即 T=1/f
3. <font color='#66ccff'>总线带宽</font>: 单位时间内通过总线的数据位数，总线的数据传输率；
   - 单位一般为 `MB/s`

> 课本 P186 【 例 1 】
> (1) 某总线在一个总线周期中并行传送 4 个字节的数据，假设一个总线周期等于一个总线时钟周期，总线时钟频率为 33MHz ，则总线带宽是多少 ?
>
> - 一个总线周期 T =1/f=1/(33 × 10^6^)
> - 一个总线周期的传送的数据量 D =4B
> - 总线带宽 Dr = D/T = D × 1/T = D × f= 4B× (33 × 10^6^)×s^-1^=132MB/s
>
> (2) 如果一个总线周期中并行传送 64 位数据，总线时钟频率升为 66MHz ，则总线带宽是多少
>
> - 总线带宽 Dr = D × f = 8B × (66 × 10^6^)×s^-1^ = 528MB/s

### 6.1.2 总线的连接方式

- 适配器：又称接口
  - 实现高速 CPU 与低速外设之间工作速度上的匹配和同步，并完成计算机和外设之间的所有数据传送和控制。
- 单机系统中，总线结构的三种基本类型：
  - 单总线结构: 使用一条单一的系统总线来连接 CPU 、内存和 I/O 设备。
  - 双总线结构: 在 CPU 和主存之间专门设置了一组高速的存储总线。
  - 三总线结构: 在各外部设备与通道之间增加一组 I/O 总线。
  - 多总线结构: 通过桥将多总线彼此相连。

#### 单总线结构

系统内的所有部件均由 <font color='#66ccff'>系统总线</font> 连接

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230512104643291.png" alt="image-20230512104643291" style="zoom: 33%;" />

- 优点：各部件之间可直接进行通信；系统易于扩充；
- 缺点：
  - 总线负载重；
  - 若有慢速设备，则会产生较大的时间延迟，降低系统的工作效率。

#### 双总线结构

#### 三总线结构

<font color='#66ccff'>系统总线</font>负责连接 CPU 、主存、 I/O 通道；
<font color='#66ccff'>存储总线</font>负责连接 CPU 与主存；
<font color='#66ccff'>I/O 总线</font>负责连接各 I/O 适配器。

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230512105031438.png" alt="image-20230512105031438" style="zoom:33%;" />

- 特点
  - 设置了通道 ，对外设进行统一的管理，分担了 CPU 的工作。
  - 提高了 CPU 工作效率，同时也最大限度的提高外设的工作速度。
  - 但硬件成本进一步增加。

![img](https://img-blog.csdnimg.cn/20210120082335300.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210120082438589.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210120082941849.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210120083119763.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210120083207120.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/2021012008335890.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210120083732931.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210120083918649.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210120084056105.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) ![img](https://img-blog.csdnimg.cn/20210120084407305.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

### 6.1.3 总线的内部结构

1. 早期总线内部结构
   - 实际是 CPU 芯片引脚的延伸；
   - 早期总线的不足
     - CPU 是总线上惟一的主控者。
     - 总线结构与 CPU 紧密相关，通用性较差。
2. 现代总线
   - 多采用标准总线
     - 与结构、 CPU 、技术无关；
     - 又被称为底板总线。
   - 现代总线可分为四个部分：
     - 数据传送总线: 地址线、数据线、控制线；
     - 仲裁总线: 总线请求线、总线授权线；
     - 中断和同步总线: 中断请求线、中断认可线；
     - 公用线: 时钟信号、电源等；

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230512105437627.png" alt="image-20230512105437627" style="zoom: 33%;" />

## 6.2 总线接口

### 6.2.1 信息的传送方式

- 串行传送
  - 使用一条传输线，采用脉冲传送，有脉冲时表示数字“ 1”1”，无脉冲时表示数字“ 0” 。
  - 采用位时间来让设备识别在某段时间内传输的 0” 和“ 1” 。
  - 特点：成本比较低廉，信息传送速度慢；
- 并行传送
  - 每一数据位需要一条传输线，一般采用电位传送，所有的位同时被传送。
    例如采用 32 条单独的地址线，可以从 CPU 的地址寄存器同时传送 32 地址信息给主存；
  - 系统总线的信息传送方式。
- 分时传送:
  - 总线传送信息的分时复用
    - 某个传输线上既传送地址信息，又传送数据信息。
    - 例如：CPU 中的复用引脚
  - 共享总线部件对总线的分时复用
    - 在不同的时间内由不同的部件使用总线。
    - 例如：系统中主模块对总线的争用

### 6.2.2 接口的基本概念

> 接口是 CPU 和主存、外设之间通过总线进行连接的逻辑部件。

- 接口

  - I/O 设备适配器；
  - 指 CPU 和主存、外围设备之间通过总线进行连接的逻辑部件。
  - 动态链接两个部件，起到“转换器”的作用，以便实现彼此之间的信息传送。

- 接口的典型功能

  - 控制、缓冲、状态、转换、整理、程序中断等。

- 一个适配器必有两个接口

  - 一个同系统总线相连，采用并行方式；
  - 另外一个同设备相连，可能采用并行方式或是串行方式。

- CPU 、接口和外围设备之间的连接关系

  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230512110403231.png" alt="image-20230512110403231" style="zoom: 33%;" />

> 课本 P193 【 例 2 】
> 利用串行方式传送字符，每秒钟传送的比特 (位数)常称为波特率。
> 假设数据传送速率是 120 个字符/秒，每一个字符格式规定包含 10 位（起始位、停止位、 8 个数据位），问传送的波特率是多少?每位占用的时间是多少?
>
> - 解：
>   - 波特率为：10 位 × 120/ 秒 =1200 波特
>   - 每个 bit 占用的时间 Td 是波特率的倒数：Td=1/1200=0.833× 0.001s=0.833ms

## 6.3 总线仲裁

### 6.3.0 总线的仲裁

1. 连接到总线上的功能模块有 <font color='#66ccff'>主动</font> 和 <font color='66ccff'>被动</font> 两种形态；
   - 主方: 可以启动一个总线周期；
   - 从方: 只能响应主方请求；
   - 每次总线操作，只能有一个主方，但是可以有多个从方。
2. 多个功能模块争用总线时，必须由<font color='66ccff'>总线仲裁部件</font>选择一个主设备使用总线
3. <font color='#66ccff'>总线占用期</font>: 主方持续控制总线的时间。
4. 总线仲裁方式（两种方式）
   - 集中式：由<font color='#66ccff'>中央仲裁器</font>决定总线使用权的归属。
   - 分布式：多个仲裁器竞争使用总线。

### 6.3.1 集中式仲裁

1. <font color='#66ccff'>链式查询方式</font>
   - 连接方式
     - 采用 菊花链 的方式连接 所有具有总线使用能力的部件
     - 各设备 共用 一根总线请求信号线 BR 、总线授权信号线 BG 、总线忙信号线 BS 与中央仲裁器连接；
     - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230512112845237.png" alt="image-20230512112845237" style="zoom:33%;" />
   - 工作方式
     - 总线授权信号 BG 串行地从一个 I/O 接口传送到下一个 I/O 接口
   - 隐含请求优先级: 离仲裁器近的优先级高
2. <font color='#66ccff'>计数器定时查询方式</font>
   - 连接方式
     - 省去总线授权信号 BG
     - 增加计数器 和 设备地址线号线 ，每次相应总线申请，由计数值决定响应的顺序。
     - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230512113234060.png" alt="image-20230512113234060" style="zoom:33%;" />
   - 工作方式
     - 有总线请求时，发出计数值，选择设备查询请求状态，依次查询每一个设备；
     - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530121649695.png" alt="image-20230530121649695" style="zoom:50%;" />
     - 如果每一次计数器从 0 开始，则和链式查询优先级一样。
     - 计数器如果从上一次终止点开始，则每一个设备的优先级一样。
3. <font color='#66ccff'>独立请求方式</font>
   - 连接方式
     - 每个部件均有 独立的请求和响应信号线 ，由中央仲裁器的内部排队逻辑决定响应顺序。
     - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530121825798.png" alt="image-20230530121825798" style="zoom:50%;" />
     - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530121942054.png" alt="image-20230530121942054" style="zoom:50%;" />

> 小结: 集中式仲裁的三种方式
>
> 1. 链式查询方式
>    - 设备的优先权 ==与总线控制器的距离== 有关；
>    - 优点 ：硬件连接简单，判优容易，设备增删容易
>    - 缺点 ：对电路故障敏感，优先级固定
> 2. 计数器定时查询方式
>    - 设备的优先权由 ==计数值== 决定，计数值为 0 时同链式查询方式；
>    - 优点 ：优先权控制灵活，对电路故障不敏感
>    - 缺点 ：硬件成本增加，控制复杂度高
> 3. 独立请求方式
>    - 设备的优先权由 ==中央仲裁器的内部排队逻辑== 决定；
>    - 优点 ：响应时间快，即确定优先响应的设备花费的时间少; 对优先次序的控制也是相当灵活的；
>    - 缺点 ：硬件复杂度高。

### 6.3.2 分布式仲裁

特点：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。

- 当设备**有总线请求**时，它们就把各自唯一的**仲裁号发送到共享的仲裁总线**上
- 每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较；
- 如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号；
- 最后，获胜者的仲裁号保留在仲裁总线上。

分布式仲裁是以 **优先级仲裁策略** 为基础。

## 6.4 总线的定时&数据传送模式

### 6.4.1 总线的定时

1. ==总线的信息传送过程== : 请求总线、总线仲裁、寻址、信息传送、状态返回
2. <font color='#66ccff'>定时</font>: 确定事件 出现 在总线上的 时序 关系
3. 定时的分类：
   - 同步定时
   - 异步定时

#### 同步定时

1. <font color='#66ccff'>同步定时</font>: 系统采用 ==统一的时钟信号== ，所有事件的出现时间均由该时钟信号确定
   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530111348310.png" alt="image-20230530111348310" style="zoom: 67%;" />
2. 优缺点
   - 优点
     - 各模块配合简单一致
     - 数据传输效率较高；
   - 缺点：
     - 各模块的速度**差异较大**时, 会影响系统的整体工作效率；
     - 时钟信号受到干扰时，会引起错误的同步；
   - 适用于总线长度较短，各功能模块速度相差不多的系统。

#### 异步定时

1. <font color='#66ccff'>异步定时</font>: 系统依靠 <font color='#66ccff'>应答方式</font> 或 <font color='#66ccff'>互锁机制</font> 来决定事件出现的时间。
   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530111542009.png" alt="image-20230530111542009" style="zoom:50%;" />
2. 优缺点
   - 优点
     - 总线周期长度可变；
   - 缺点
     - 增加了总线的复杂性和成本；
   - 适用于设备工作速度不一致的系统
3. 异步定时的互锁机制: 一般把异步应答关系分为不互锁、半互锁和全互锁 3 种类型
   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530113154443.png" alt="image-20230530113154443" style="zoom: 33%;" />

### 6.4.2 总行数据传送模式

1. <font color='#66ccff'>读、写操作</font>
   - 主设备利用系统总线，完成与从设备直接的数据传送；
2. <font color='#66ccff'>块传送操作</font>
   - 只需给出块的起始地址，然后对固定块长度的数据一个接一个地读出或写入。
3. <font color='#66ccff'>写后读、读修改写操作</font>
   - 只给出地址一次，或先写后读（校验），或先读后写（多道程序系统中对共享存储资源的保护）
4. 广播、广集操作
   - <font color='#66ccff'>广播</font>：总线允许一个主方对多个从方进行写操作。
   - <font color='#66ccff'>广集</font>：与广播相反的操作，它将选定的多个从方数据在总线上完成 AND 或 OR 操作，用以检测多个中断源

> 假设某系统总线在一个总线周期中并行传输 4 字节信息，一个总线周期占用 2 个时钟周期，总线时钟频率为 10MHz ，则总线带宽是（**B**）
> A. 10MB/s B.20MB/S C. 40MB/S D.80MB/S

- $总线带宽Dr=D/2T=D\times 0.5f=4B\times 0.5\times 10\times 10^6s^{-1}=20MB/s$

## 6.5 PCI 总线和 PCIe 总线

1. 多总线结构实例
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530115641025.png" alt="image-20230530115641025" style="zoom:50%;" />
2. <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530120018185.png" alt="image-20230530120018185" style="zoom:50%;" /> 
   - <font color='#66ccff'>HOST总线 (CPU总线, 系统总线, 主存总线, 前端总线)</font>： 宿主总线，用于 CPU 与主存系统之间信息传送
   - <font color='#66ccff'>PCI 总线</font>： 是一个与处理器无关的**高速外围总线**，又是至关重要的**层间总线**
     - PCI: Peripheral Component Interconnect 外部链接标准; Personal Computer Interface 个人计算机接口
     - 采用**同步时序协议**和**集中式仲裁策略**，并具有**自动配置**能力
     - 其基本传送机制是**猝发式**传送
   - <font color='#66ccff'>LAGACY总线</font>： 中、低速I/O总线
   - <font color='#66ccff'>桥</font>的作用：总线之间的通信部件，可以将一条总线的地址空间映射到另一条总线的地址空间

#### PCI 总线

- PCI 信号线:
  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530120726384.png" alt="image-20230530120726384" style="zoom:50%;" />
- PCI 总线的命令与编码
  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530120759873.png" alt="image-20230530120759873" style="zoom:67%;" />
- 主要的总线操作
  1. 典型的 PCI 读
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530120848785.png" alt="image-20230530120848785" style="zoom:50%;" />
  2. 典型的 PCI 写
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530120920635.png" alt="image-20230530120920635" style="zoom:50%;" />
  3. 总线的仲裁
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530121015773.png" alt="image-20230530121015773" style="zoom:50%;" />
     集中式、隐藏式仲裁

#### PCIe 总线

- 总线的发展历程
  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530121112428.png" alt="image-20230530121112428" style="zoom:50%;" />
- <font color='#66ccff'>PCI-Express</font> (peripheral component interconnect express PCIe) : 一种高速串行计算机扩展总线标准，旨在替代旧的 PCI PCI-X 和 AGP 总线标准
- PCIe 特点
  - 对 **PCI 有良好的继承性** ，并进行改进
  - 高速**差分**、**串行**传输
  - 使用**端到端** 、基于**数据包** 、支持**多通道的**传递方式
    <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230530121418586.png" alt="image-20230530121418586" style="zoom:50%;" />

## 6.6 本章开头提出的问题回答

1. 引入总线结构有什么好处？

   - 引入总线结构主要有以下优点
   - ① 简化了系统结构，便于系统设计制造。
   - ② 大大减少了连线数目，便于布线，减小体积，提高系统的可靠性
   - ③ 便于接口设计，所有与总线连接的设备均采用类似的接口。
   - ④ 便于系统的扩充、更新与灵活配置，易于实现系统的模块化
   - ⑤ 便于设备的软件设计，所有接口的软件对不同的接口地址进行操作。
   - ⑥ 便于故障诊断和维修，同时也能降低成本。

2. 引入总线会导致什么问题？如何解决？
   - 引入总线后，总线上的各个设备分时共享同一总线，当总线上多个设备同时要求使用总线时就会导致总线的冲突。为解决多个主设备同时竞争总线控制权的问题，应当采用总线仲裁部件，以某种方式选择一个主设备优先获得总线控制权，只有获得了总线控制权的设备才能开始数据传送。

## 6.7 常见问题

1. 同一个总线不能既采用同步方式又采用异步方式通信吗？

   - 半同步通信总线可以。这类总线既保留了同步通信的特点，又能采用异步应答方式连接速度相差较大的设备。通过在异步总线中引入时钟信号，其就绪和应答等信号都在时钟的上升沿或下降沿有效，而不受其他时间的信号干扰。 例如，某个采用半同步方式的总线总是从某个时钟开始，在每个时钟到来时，采样 Wait 信号，若无效，则说明数据未准备好，下个时钟到来时，再采样 Wait 信号，直到检测到有效，再去数据线上取数据。PCI 总线也是一种半同步总线，它的所有事件都在时钟下降沿同步，总线设备在时钟开始的上升沿采样总线信号。

2. 一个总线在某一时刻可以有多对主从设备进行通信吗？
   - 不可以。在某个总线周期内，总线上只有一个主设备控制总线，选择一个从设备与之进行通信（即一对一的关系），或对所有设备进行广播通信（即一对多的关系）。所以一个总线在某一时刻不能有多对主从设备进行通信，否则会发生数据冲突。

![img](https://img-blog.csdnimg.cn/20210119200603623.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

# 第七章 外围设备

## 7.1 外围设备概述

1. 外围设备的定义:计算机系统（主机)与外界交换信息的装置。
   - 计算机系统中，除 CPU 和主存之外的部件都可看作外设
2. 外围设备的功能:
   - 在计算机和其他机器，或与用户之间提供联系。
3. 外围设备的基本组成:
   - 存储介质: 用于信息的保存;
   - 驱动装置: 用于移动存储介质,使之正常工作;
   - 控制电路: 用于使该外设与外界(如 CPU)的信息传递。
4. 外围设备分类
   - 输入 出设备；
   - 外存设备；
   - 数据通信设备；
   - 过程控制设备；
   - ……
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230531161441778.png" alt="image-20230531161441778" style="zoom: 80%;" />
   - 外设都是通过适配器与主机连接的, 适配器控制所连外设的具体工作

## 7.2 磁盘存储设备

### 7.2.1 磁记录原理

1. 磁表面存储器：利用 **磁性材料** 来存储信息。
2. 磁记录原理：利用磁性材料在外加磁场的作用下产生矩形磁滞回线的特性记录二进制信息。外加磁场由外加脉冲电流产生。
3. 磁表面存储器的优缺点
   - 优点
     - 存储容量大 ，位价格低
     - 记录介质可以 重复使用
     - 记录信息可以长期保存而不丢失
     - 非破坏性读出 ，读出时不需要再生信息
   - 缺点
     - 存取速度较慢，机械结构复杂
     - 非接触式读写，对工作环境要求较高
4. 磁表面存储器的读写原理
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230609212041630.png" alt="image-20230609212041630" style="zoom:50%;" />
   - 在磁表面存储器中，信息的读写是利用**磁头**来进行的；
     - <font color='#66ccff'>磁头</font>：由软磁材料做铁芯，绕有读写线圈的电磁铁。
   - 写操作
     - 原理： 电–磁变换；
     - 利用磁头写线圈中的脉冲电流，在磁表面每个存储元上形成不同的磁化状态；
   - 读操作
     - 原理： 磁–电变换；
     - 利用磁头读线圈，将磁表面每个存储元上的不同剩磁状态转换成电信号读出；

### 7.2.2 磁盘的组成和分类

1. 硬盘组成： 磁记录介质、磁盘控制器、磁盘驱动器

   - 磁记录介质：由一组硬质圆形盘片的磁表面存储器组成
   - 磁盘控制器：由控制逻辑与时序、串–并互换电路等组成。是主机与磁盘驱动器之间的接口
   - 磁盘驱动器：由读写电路、读写转换开关、读写磁头和磁头定位伺服系统组成。是一种精密的电子和机械装置

2. 硬磁盘的分类
   - 按盘片结构分: 可换盘片式、固定盘片式
   - 按磁头分: 可移动磁头、固定磁头
   - 组合 $\Longrightarrow\begin{cases}固定磁头固定盘片\\固定磁头可换盘片\\可移动磁头固定盘片\\可移动磁头可换盘片\end{cases}$
3. 温彻斯特磁盘机 (简称温盘): **可移动磁头 固定盘片**的磁盘机；

   - 密封组合式的硬磁盘: 磁头、盘片、电机等部件组装成一个**不可随意拆卸**的整体。
   - 工作时，高速旋转在盘面上形成的**气垫**将磁头平稳浮起。
   - 优点：防尘性能好，可靠性高，对使用环境要求不高。

### 7.2.3 磁盘上信息的分布 ★

- <font color='#66ccff'>记录面</font>： 盘片的表面，**双面**都能记录信息。

- <font color='#66ccff'>磁道</font>：磁盘旋转一周后写入的数据位形成的环形。 每道**存储容量相同**，**位密度不同**。

  - <font color='#66ccff'>圆柱面</font>：所有盘片相同编号的磁道所构成的柱面

- <font color='#66ccff'>扇区</font> ：同心圆上的一段磁道区域

  - 磁盘的最小单位
  - 一个扇区通常 512KB

- 每个磁道可以划分固定长度的扇区。每个扇区分成前导区（头空）、序标（用于同步 、数据区、纠错码）和隔离带（尾空）。
  <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230609215456380.png" alt="image-20230609215456380" style="zoom:67%;" />

  - 一道划分多少扇区，每个扇区可存放多少字节 ，一般由操作系统决定。
  - 每个扇区的存储容量相同

- 数据读取流程

  1. 磁头沿径向移动， 将磁头**定位**在磁道上
  2. 磁盘高速转动，等待磁盘将数据旋转到磁头下方
  3. 访问数据

  - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230718105804995.png" alt="image-20230718105804995" style="zoom: 33%;" />

  - 磁盘地址组成：磁道号（柱面号）、记录面号（磁头号）、扇区号
  - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230609221200125.png" alt="image-20230609221200125" style="zoom:50%;" /> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230609221211985.png" alt="image-20230609221211985" style="zoom:50%;" />

### 7.2.4 磁盘存储器的技术指标

- 存储密度： 分成道密度、位密度和面密度。
  - 道密度： 磁盘**半径**方向单位长度上的磁道数
  - 位密度： 单位**长度**<font color='orange'>(圆的边长)</font>内存储的二进制位；
    - 每个磁道的位密度均不相同，有最高、最低位密度。第 0 道对应最大位密度
      <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230609222100820.png" alt="image-20230609222100820" style="zoom:50%;" />
  - 面密度 ：单位**面积**内存储的二进制位；
- 存储容量： 一般以字节为单位。
  - $\textcolor{#66ccff}{非格式容量}=最大位密度 \times 最内圈磁道周长 \times 总磁道数$；
  - $\textcolor{#66ccff}{格式化容量}=每道扇区数 \times 扇区容量 \times 总磁道数$。
- <font color='#66ccff'>平均存取时间($T_a$)</font>：指从发出读写命令后，磁头从某一起始位置移动至新的记录位置，到开始从盘片表面读出或写入信息所需要的时间
  - <font color='#66ccff'>寻道时间（定位时间）$T_s$</font>：将磁头定位到目标道的时间
  - <font color='#66ccff'>(平均)等待时间</font>：寻目标起始扇区的时间。常用磁盘转一周的**一半时间**表示，与转速有关。
    - 若 r 为转速，则为$\frac 1{2r}$
  - <font color='#66ccff'>数据传送时间</font>：数据从扇区读到主机的时间，与转速有关。
    - 若读取的字节为 b，每磁道字节数为 N，则为$\frac b{rN}$
  - $\textcolor{#66ccff}{T_a=T_s+\frac 1{2r}+\frac b{rN}}$
- <font color='#66ccff'>数据传输率$D_r$</font>（数据存取速度 ）：磁盘控制器在单位时间内向主机传送数据的字节数。与转速和磁道容量有关。
  - $\textcolor{#66ccff}{D_r = N \times n=每磁道字节数\times 盘片转速=D \times v =位密度 \times 盘片线速度}$
- 寻址过程：
  1. 主机向磁盘控制器送寻址信息 ：驱动器号、圆柱面号（磁道）、 记录面号（磁头）、起始扇区号、交换量。
  2. 寻道 （毫秒级 ）：查找时间
  3. 寻起始扇区 （毫秒级）：等待时间
  4. 读写数据

> 例 1: 磁盘组有 6 片磁盘，每片有两个记录面，最上最下两个面不用。
> 存储区域内径 22cm ，外径 33cm ，道密度为 40 道/cm ，内层位密度 400 位/cm ，转速 6000 转/分。问：

1. 共有多少柱面
   - $(33-22) / 2 \times 40=220(道)$
2. 盘组总存储容量是多少
   - 内层磁道周长为$2πR=2 × 3.14 × 11=69.08(cm)$
   - $每道信息量 =400 位 /cm × 69.08cm=27632 位 =3454B$
   - $每面信息量 =3454B × 220=759880B$
   - $盘组总容量 =759880B × 10=7598800B$
3. 数据传输率多少
   - $r=6000 转 /60 秒 =100 转/秒$
   - $传输率 D_r=rN =100 × 3454B=345400B/s$
4. 采用定长数据块记录格式，直接寻址的最小单位是什么 寻址命令中如何表示磁盘地址
   - 直接寻址的最小单位是一个记录块 (一个扇区)
   - 地址：驱动器（台）号、柱面（磁道）号、盘面（磁头）号、扇区号
5. 如果某文件长度超过一个磁道的容量，应将它记录在同一个存储面上，还是记录在同一个柱面上
   - 同一个柱面上

> 例 2: 某硬盘存储器转速为 2400 转/分，每个记录面道数为 200 个/道，平均查找时间为 60ms ，每道存储容量为 96Kb ，试计算该磁盘的存取时间与数据传速率。

- 转速: 2400 转/分=40 转/s
- $平均等待时间=\frac 1{2\times40}=12.5ms$
- 数据传送时间 1/40=0.025s=25ms
- 磁盘存取时间=60+12.5+25=97.5ms
- 数据传速率=40\*96=3840Kbit/s

## 7.3 磁盘存储设备的技术发展 <了解>

- 磁盘 cache
  - 目的：提高磁盘速度；
  - 原理：空间局部性和时间局部性；
  - 材料： SRAM 或 DRAM 。
- 磁盘阵列 RAID （廉价冗余磁盘阵列）
  - 基本原理：利用数据分块技术和并行处理技术，在多个磁盘上交错存放数据，使之可以并行存取。
  - 存取方式：并行存储、交叉存储、单独存储。
- 可移动硬盘

## 7.4 磁带存储设备<了解>

## 7.5 光盘和磁光盘存储设备<理解>

### 7.5.1 光盘工作原理

- 特点：容量大、非易失性、成本低、可移动性、速度慢，数据传输率低。

- 光盘组成：光盘控制器、光盘驱动器、存储介质（光盘）。

  - 驱动器 ：读写头、寻道定位机构
  - 控制器 ：数据输入缓冲器、记录格式器、编码器、读出格式器、数据输出缓冲器等。
  - 存储介质 ：形变形、相变型、磁光型。

- 光盘分类：

  - 只读型（CD ROM 、 DVD–ROM）
  - 一次写入型
    - 一次写（ WROM）
    - 分段写（ CD–R 、 DVD–R）
  - 可擦写型：磁光盘

- 光盘的信息分布： 光道、扇区。

- 光盘的扇区结构

  - ![image-20230610151837305](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230610151837305.png)
  - 同步(SYNC)区： 12 字节标志扇区的开始。
  - 扇区标识(ID)区： 4 字节，说明此扇区的地址和工作模式。
    - 光盘的扇区地址以 分(MN), 秒(SC) 和 分数秒 (FR, 1/75s) 时间值作为编码。
      且光盘的线速度恒定为**每秒钟读出 75 个扇区**，故 FR 的值实际上就是秒内的扇区号 (0~74) 。
    - MD 为模式控制，用于控制数据区和校验区的使用。共有三种模式。
  - 数据区
  - 校验区

- > 例 3 CD–ROM 光盘的外缘有 5mm 宽的范围因记录数据困难，一般不使用，故标准的播放时间为 60 分钟。
  >
  > 计算模式 1 和模式 2 情况下光盘存储容量是多少

  - 模式 1 ：每扇区数据是 2048B
  - 模式 2 ：每扇区数据是 2336B
  - 扇区总数 = 60 分 x60 秒 × 75 扇区 秒 =270000 扇区
  - 模式 1 数据容量：270000 × 2048B=527MB
  - 模式 2 数据容量：270000 × 2336B=601MB

### 7.5.2 磁光盘存储设备

- 特点：可擦除。
- 磁光盘的信息分布：磁道、扇区。
- 磁光盘的读写原理

  - 写：高功率激光束将磁光介质上的记录点加热到居里点温度以上，用外加磁场改变记录点的磁化方向。（热磁效应）
  - 读：在低功率激光束照射下，记录点的磁化方向不同会引起发射光的偏振面发生不同的结果（磁光克尔效应）。
  - 擦除：高功率激光束照射记录点，外加磁场改变方向，恢复磁性粒子

- 硬盘、软盘、磁带、光盘的性能比较

  |      | 速度 | 可换性 | 读写方式 | 价格                | 容量 | 使用场合                     |
  | ---- | ---- | ------ | -------- | ------------------- | ---- | ---------------------------- |
  | 硬盘 | 高   | 不可以 | 非接触式 | 较高                | 较大 | 作为主存后援，存放软件、数据 |
  | 磁带 | 低   | 可以   | 接触式   | 较低(磁带机+磁带)   | 较小 | 海量后备(顺序存储)           |
  | 光盘 | 较高 | 可以   | 非接触式 | 高(可擦写光驱+光盘) | 大   | 存软件, 图文资料, 档案等     |

## 7.6 显示设备

- 显示器： 以可见光的形式输出信息的设备，属于软拷贝输出设备。
- 显示器分类
  - 按显示器件分类：阴极射线管（ CRT ）显示器、液晶显示器 LCD ）、等离子显示器。
  - 按信息内容分类：字符显示器、图形显示器和图象显示器。
  - 以扫描方式不同分成： 光栅扫描和随机扫描 两种显示器；
  - 以分辨率不同分成：高分辨率显示器和低分辨率显示器；
  - 以显示的颜色分类：单色 黑白 显示器和彩色显示器；
  - 以荧光屏对角线长度分类： 14 英寸、 16 英寸、 19 英寸等多种。
- 显示器中的有关术语
  - 像素： 构成图像的基本单位。
  - 分辨率： 显示器能表示的像素个数。
    - 字符显示器：一屏可显示的最多字符数；
    - 图像显示器：一屏可显示的最多像点数
  - 灰度级： 像素明暗差别的程度。
  - 颜色数： 显示器能显示的颜色的种类。
  - 刷新： 显示中重复扫描像素的操作过程。
    - 刷新频率显示器每秒能够对整个屏幕的刷新次数。
      一般设置刷新频率为 70Hz 以上
- 刷新存储器: 存放图像信息用于刷新的存储器，也叫 显示存储器
  - 在 显示器的控制器 中，用于 存放一帧显示内容 的存储器。
  - 其存储容量由图像 分辨率 和 灰度级 决定；
  - 刷新存储器的存取周期必须满足刷新频率的要求。
  - 存储器容量 分辨率 × 颜色深度
  - 容量：M = r x C (r: 分辨率， C：灰度级)
- PC 机显示适配器
  - 主要构成部件
    - 刷新存储器：存放显示图案的点阵数据。其存储容量取决于设定的显示工作方式。
    - ROM BIOS ：固化软件，用于支持显示控制器建立所要求的显示环境。
    - 显示控制器：控制各个部件将图像数据显示在显示器上。
- 显示标准: 随着 IBM PC 系列机的升级发展， PC 机采用的显示标准经历了如下变化：MDA → CGA → EGA →VGA → SuperVGA

- > 例 4 、 刷存的重要性能指标是它的带宽。实际工作时显示适配器的几个功能部分要争用刷存的带宽。假定总带宽的 50% 用于刷新屏幕，保留 50% 带宽用于其他非刷新功能。
  > (1)若显示工作方式采用分辨率为 1024 × 768 ，颜色深度为 3B ，帧频 刷新速率 为 72Hz, 计算刷存总带宽应为多少 ?
  >
  > (2)为达到这样高的刷存带宽，应采取何种技术措施

  - 刷新所需带宽=分辨率 × 每个像素点颜色深度 × 刷新速率=1024× 768 × 3B × 72/s=165888KB/s=162MB/s
    刷存总带宽应为 162MB/s × 100/50=324MB/s
  - 可采用如下技术措施：
    - 使用高速的 DRAM 芯片组成刷存；
    - 刷存采用多体交叉结构；
    - 刷存至显示控制器的内部总线宽度由 32 位提高到 64 位，甚至 128 位
    - 刷存采用双端口存储器结构，将刷新端口与更新端口分开

## 7.7 输入设备和打印设备

- 输入设备
  - 图形输入设备: 键盘 、鼠标、图形板和游动标
  - 图像输入设备: 数码照相机、数码摄像机 、扫描仪
  - 语音输入设备: 语音识别器
- 打印设备: 针式打印机 、喷墨打印机、激光打印机

# 第八章 输入/输出系统

## 【复习提示】

I/O 方式是本章的重点和难点，每年不仅会以选择题的形式考查基本概念和原理，而且可能会以综合题的形式考査，特别是各种 IO 方式效率的相关计算，中断方式的各种原理、特点、处理过程、中断屏蔽，DMA 方式的特点、传输过程、与中断方式的区别等。

在学习本章时，请读者思考以下问题

- 1)IO 设备有哪些编址方式？各有何特点？
- 2)CPU 响应中断应具备哪些条件？

请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。 ![img](https://img-blog.csdnimg.cn/20210118102514764.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70) 【复习提示】 I/O 方式是本章的重点和难点，每年不仅会以选择题的形式考査基本概念和原理，而且可能会以综合题的形式考査，特别是各种 IO 方式效率的相关计算，中断方式的各种原理、特点、处理过程、中断屏蔽，DMA 方式的特点、传输过程、与中断方式的区别等。 在学习本章时，请读者思考以下问题：

- 1)I/O 设备有哪些编址方式？各有何特点？
- 2)CPU 响应中断应具备哪些条件？

请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。

## 8.1 外围设备的速度分级与信息交换方式

1. <font color='#66ccff'>接口</font>: 为 CPU 和主存、 I/O 设备之间传送信息而设的转换逻辑部件。

2. 输入输出设备同 CPU 交换数据的过程：

   - 输入过程：
     - CPU **送地址选择**某一输入设备；
     - CPU 等候数据成为有效
     - CPU **读**入数据， **存**入相应的寄存器中。
   - 输出过程：
     - CPU 送地址**选择**某一输出设备；
     - CPU 把数据放在**数据总线**上；
     - 输出设备**取**数据。

3. CPU 与外设之间定时方式： 与速度相关 。

   - 速度极慢或简单的外设：直接交换。
   - 中速的外设：采用应答式交换，即异步定时方式。
   - 高速外设：同步定时方式

4. 主机与外设信息交换方式

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230519141234822.png" alt="image-20230519141234822" style="zoom:33%;" />

   - <font color='#66ccff'>直接程序控制方式</font>： CPU 通过 I/O 指令 对 I/O 设备进行访问， **主机与外设交换信息的每一过程均在程序中表示**出来
     - 立即程序传送方式： 不询问外设状态， 根据程序情况随时向外设传送数据
     - 程序查询方式： 根据外设的工作状态，在相应外设准备好时再向外设传送数据
       - 优点：操作简单。
       - 缺点：CPU 效率低。
   - <font color='#66ccff'>程序中断方式</font>： 当有某些 随机事件 发生时 CPU 暂停执行当前的程序 ，转去 执行引起中断的程序 ，处理完后再返回继续执行原程序 。
     - 优点 : CPU 效率高；
     - 缺点：大批量传送速度慢。
   - <font color='#66ccff'>直接内存访问(DMA)方式</font>: 通过硬件控制总线，实现 主存与 I/O 设备间的直接数据传送 ，在传送过程中 无需 CPU 程序干预
     - 优点： CPU 效率高，速度快，适合大批量数据传送；
     - 缺点：增加硬件，成本较高。
   - <font color='#66ccff'>通道方式</font>： 通过执行通道（一种专用控制器）程序进行 I/O 操作的管理。

## 8.2 程序查询方式

> <font color='#66ccff'>程序查询方式</font>: 在 CPU 的主动控制 下，通过 执行程序 完成 CPU 与外设之间的信息传送

1. 设备的编址方式

   - **与存储器统一编址**: 在存储器总的地址空间中分出一个区域，作为 I/O 系统中的设备地址。
     - 优点:访问简单，操作灵活，不需专门的指令;
     - 缺点:占用部分存储器空间。
   - **独立编址**:内存与外围设备地址各自独立。
     - 优点:不占用存储器空间;
     - 缺点:需专门的指令。

2. 输入/输出指令

3. 程序查询方式接口设计

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230519143322071.png" alt="image-20230519143322071" style="zoom: 67%;" />

   - 设备选择电路
   - 数据缓冲寄存器
   - 设备状态标志电路

4. 程序查询方式流程

   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230519144839275.png" alt="image-20230519144839275" style="zoom:50%;" /> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230519145438938.png" alt="image-20230519145438938" style="zoom:60%;" />
   - 多个外围设备查询(轮询)时, 一般先询问**数据传输速率高**的设备

## 8.3 程序的中断方式 ★

### 8.3.1 中断概念

1. <font color='#66ccff'>中断（程序中断）</font>：当有某些 随机事件 发生时 CPU 暂停执行当前的程序 ，转去执行引起中断的程序 ，处理完后再 返回继续执行原程序
   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230519162317894.png" alt="image-20230519162317894" style="zoom:50%;" />
2. 中断特征：程序转换和随机性、排优性。
3. 中断作用：
   - 实现 CPU 与外设并行工作；
   - 提高系统处理故障的能力， 增强可靠性
   - 实现实时处理；
   - 系统调度；
   - 实现人机交换；
   - 实现多机通信。
4. 中断处理过程的流程
   1. 中断请求： 中断源 (分成 <font color='#66ccff'>可屏蔽中断</font>和<font color='#66ccff'>非屏蔽中断</font>) 请求 CPU 为自己服务的过程；
      - 排优： 当 有几个中断同时请求时, 按照==优先排队== 顺序响应；
   2. 中断响应：<font color='orange'>(硬件完成)</font>
      - CPU 进入中断响应周期 (INTA), 如是**非屏蔽中断**马上响应；
        如是**可屏蔽中断**则在中断允许有效 (`IM=0`) 下, 响应中断；
      - 保存硬件现场 (程序计数器值和状态寄存器值), **关中断**允许标志 (`IM=1`), 读中断服务程序入口地址 。
   3. 中断服务 <font color='orange'>(软件)</font>
      - 处理中断:（即运行中断服务子程序） 保护软件现场 ，执行中断服务程序， 恢复现场, 开中断 。
      - 中断返回： 恢复被中断程序处地址 ，继续执行原程序。
   4. <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230519152708988.png" alt="image-20230519152708988" style="zoom:50%;" />

### 8.3.2 程序中断方式的基本接口电路

- BS: 启动接口工作 **标志**触发器。
- RD: 外设准备就绪 **标志**触发器。
- EI: 允许外设中断触发器。
  - 设置 EI 标志的目的：通过软件来控制是否允许某设备发出中断请求
- 中断向量逻辑：形成中断服务子程序的入口 地址
- 数据缓冲寄存器： 暂存数据。
- 设备选择: 地址译码逻辑。

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230519160105042.png" alt="image-20230519160105042" style="zoom: 67%;" />

### 8.3.3 单级中断

- 单级中断: 所有中断优先级相同，一旦响应一个中断后，只有服务完才可响应其他中断

  - **系统结构**： 公共请求线方式。

  - **中断源识别方式**： 链式查询方式
  - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230519162302617.png" alt="image-20230519162302617" style="zoom:50%;" />
  - 查询顺序决定优先级

- <font color='#66ccff'>向量地址</font>: 当 CPU 响应中断时，由 硬件直接产生一个固定的地址
  <font color='#66ccff'>向量中断</font>: 由向量地址指出每个中断源设备的中断服务程序入口
  - 一级向量方式： 地址码直接对应中断程序入口地址；
  - 二级向量方式： 地址码经转换后得到中断程序入口地址。

### 8.3.4 多级中断

1. <font color='#66ccff'>多级中断</font>: 系统中的多个中断源具有不同的优先级 。低优先级中断处理过程中可以 被高优先级的中断源打断 ，实现中断嵌套。

   - <img src="C:/Users/14258/AppData/Roaming/Typora/typora-user-images/image-20230519103006163.png" alt="image-20230519103006163" style="zoom:33%;" />

2. <font color='#EE0000'>特点–part1</font>

   - 在多级中断之间可以实现中断嵌套，但在同一级不可以嵌套
     - 同一级别不能嵌套, 按照单级中断的逻辑进行(如上图, 两个三级先后响应)
   - 由 中断堆栈 按顺序保护现场

3. 多级中断的类型

   - 一维中断：同一个优先级里只有一个中断源。
   - 二维中断：同一个优先级里有多个中断源。

4. 多级中断的请求与响应

   - <img src="C:/Users/14258/AppData/Roaming/Typora/typora-user-images/image-20230519104157195.png" alt="image-20230519104157195" style="zoom:50%;" />

   - 当 `IR=1 且 IM=0` 时，该级中断请求进入排队电路等待响应
   - 中断响应后，由 ==硬件直接修改各级 IM== 的值，保证相应次序
     - <font color='#EE0000'>将本级和优先级低于本级的 IM 设为 1 ，将更高级的 IM 设为 0</font>

5. > 【例 1】 在各设备同时提出中断请求的情况下，各个设备的优先级如何？

   - A→B→C→ D→E→F→G→H →I

   > 【例 2】 若 CPU 执行设备 D 的服务子程序， IM2 IM1 IM0 的状态又是什么

   - IM2 IM1 IM0：011

6. > > 中断响应顺序由硬件决定, 但是根据需求, 可以==在服务子程序中对各级的 IM 进行修改==
   >
   > 某计算机系统共有五级中断 ，中断响应优先级从高到低为 1 2 3 4 5 。
   > 现按如下规定修改：
   >
   > 各级中断处理时均屏蔽本级中断，且处理 1 级中断时屏蔽 2 、3 、4 和 5 级中断；
   >
   > 处理 2 级中断时屏蔽 3 、 4 、 5 级中断；
   >
   > 处理 4 级中断时不屏蔽其他级中断；
   >
   > 处理 3 级中断时屏蔽 4 级和 5 级中断；
   >
   > 处理 5 级中断时屏蔽 4 级中断。
   >
   > 试问中断处理优先级 从高到低 顺序如何排列 并给出各级中断处理程序的中断屏蔽字 ??（设 0” 为允许，“ 1” 为禁止。）

- 1→2→3→5→4
- 1 级中断屏蔽字为 11111
  2 级中断屏蔽字为 01111
  3 级中断屏蔽字为 00111
  4 级中断屏蔽字为 00010
  5 级中断屏蔽字为 00011

7. > 某计算机有四级中断，优先级从高到低为 A > B > C > D 。假定各级中断程序的屏蔽位设置为： A 1101 B 0100 C 1111 D 0101 。请给出中断处理次序。设 A 、 B 、 C 、 D 同时请求中断，试画出 CPU 执行程序的轨迹。

- 解：中断处理次序： C > A > D > B
- <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230519163111763.png" alt="image-20230519163111763" style="zoom:50%;" />

8. <font color='#EE0000'>特点–part2</font>

   - 每级中断 CPU 中都有 <font color='#66ccff'>请求触发器 IR</font> 及 <font color='#66ccff'>屏蔽触发器 IM</font>
   - 中断响应优先顺序由==硬件设定== <font color='orange'>(不可更改)</font>

9. 多级中断小结

   - 每级中断， CPU 中都有对应的 IR 和 IM 。

   - 在多级中断之间可以实现中断嵌套，但在同一级不可以，由中断堆栈按顺序保护现场。
   - 中断**响应优先顺序**由硬件设定，中断**处理**（或中断执行）的完成顺序可以由软件设定

### 8.3.5 中断控制器

1. 微机系统中，常将其中可公用的中断控制逻辑从 I/O 接口中分离出来，集成芯片来实现向量产生、排优电路、中断屏蔽等中断控制逻辑。
   - 例 8259 ：可编程中断控制器
     8259 可管理 8 路中断请求 IR0 IR7 ，通过级联方式，最多可扩展为 64 级中断。具有多种工作模式。
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230519164334892.png" alt="image-20230519164334892" style="zoom:50%;" />

## 8.4 DMA 方式

1. <font color='#66ccff'>DMA(Direct Memory Access 直接存储器访问)</font>: 通过**硬件控制**总线实现主存与 I/O 设备间的**直接数据传送**, 在传送过程中**无需 CPU 程序干预**
   <img src="C:/Users/14258/AppData/Roaming/Typora/typora-user-images/image-20230519112120096.png" alt=" " style="zoom: 33%;" />
2. DMA 的基本工作处理过程
   - **DMA 请求**： 外设通过接口向 CPU 发 DMA 请求信号。
   - **DMA 响应**： CPU 将工作改为 DMA 操作方式，将总线控制权交给 DMA 控制器。
   - **DMA 数据传送**： DMA 控制器发总线信号，在主存和 I/O 寄存器之间传送数据。
   - **结束处理**： 数据传送完后，发结束中断请求 ，通知 CPU 进行后处理。
3. DMA 传送方式
   - CPU 与 DMA 控制器控制内存方式
     - 停止 CPU 访问内存：
       - 优点 : 控制简单，适用于数据传输率很高的设备进行成组传送。
       - 缺点 : 内存的效能没有充分发挥。
     - 周期挪用： 指在 CPU 执行访内指令的过程中插入 DMA 请求，挪用了一二个内存周期。
       - 优点：可以提高 CPU 和内存的效率，适用于 I/O 设备读写周期大于内存存储周期的情况。
       - 缺点：申请频繁，速度较慢。
   - DMA 与 CPU 交替访存： DMA 与 CPU 分时交替访问内存
     - 优点 : DMA 不需申请，适用于 CPU 工作周期比内存周期长的系统。
     - 缺点 : 设计复杂。

## 8.5 通道方式

1. <font color='#66ccff'>通道</font>：一种专用处理器 ，通过执行通道程序进行 I/O 操作的管理，为主机与 I/O 设备提供数据传送通道。
2. 通道的功能：
   - 接收 CPU 的 I/O 指令，按指令要求与指定的外围设备进行通信；
   - 从内存中或自己的局部存储器中取通道指令，经译码后向 I/O 发命令；
   - 组织外设与内存之间进行数据传送，并根据需要提供数据传送的缓存空间，提供数据存入内存的地址和传送的数据量；
   - 获取外设的状态信息，并将其存入内存，供 CPU 使用；
   - 通过中断方式报告 I/O 设备及其本身的工作情况。
3. CPU 对通道的管理
   - 执行 I/O 指令
   - 处理来自通道中断。
4. 通道对设备的管理: 通道指令

## 8.6 通用 IO 标准接口

1. SCSI 标准：小型计算机系统接口，系统级接口，处于主适配器和智能设备控制器之间的并行接口，最高速率 40MB/s ，常用于服务器，
   - 一般 SCSI 接口与设备是分离的 。
   - 分成 SCSI-1 SCSI-2 SCSI-3 ，串行 SCSI
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230520213653051.png" alt="image-20230520213653051" style="zoom: 50%;" />
2. IEEE1394 ：高速串行接口，最高速率 400Mb/s ，是一种外部串行总线标准 ，常用于新型高速硬盘和多媒体数据传送。
3. USB ：通用串行总线接口，支持热插拔，即插即用的优点分成 USB1.0 USB2.0 ，最高速率 480Mb/s 。

## 8.7 本章开头提出的问题回答

1. I/O 设备有哪些编址方式？各有何特点？

   - 统一编址和独立编址。
   - 统一编址是在主存地址中划出一定的范围作为 I/O 地址，以便通过访存指令即可实现对 I/O 的访问，但主存的容量相应减少。
   - 独立编址是指 IO 地址和主存是分开的，I/O 地址不占主存空间，但访存需专门的 I/O 指令。

2. CPU 响应中断应具备哪些条件？

   1. 在 CPU 内部设置的中断屏蔽触发器必须是开放的
   2. 外设有中断请求时，中断请求触发器必须处于“1”状态，保持中断请求信号。
   3. 外设(接ロ)中断允许触发器必须为“1”，这样才能把外设中断请求送至 CPU。

   - 具备上述三个条件时，CPU 在现行指令结束的最后一个状态周期响应中断。

## 7.6 常见问题

### 1.中断响应优先级和中断处理优先级分别指什么？

- 中断响应优先级是由硬件排队线路或中断查询程序的查询顺序决定的，不可动态改变；
- 而中断处理优先级可以由中断屏蔽字来改变，反映的是正在处理的中断是否比新发生的中断的处理优先级低(屏蔽位为“0”，对新中断开放)，若是，则**中止正在处理的中断，转到新中断去处理**， 处理完后再回到刚才被中止的中断继续处理。

### 2.向量中断、中断向量、向量地址三个概念是什么关系？

- 中断向量：每个中断源都有对应的处理程序，这个处理程序称为中断服务程序，其入口地址称为中断向量。
- 所有中断的中断服务程序入口地址构成一个表，称为中断向量表；也有的机器把中断服务程序入口的跳转指令构成一张表，称为中断向量跳转表。
- 向量地址：中断向量表或中断向量跳转表中每个表项所在的内存地址或表项的索引值，称为向量地址或中断类型号。
- 向量中断：指一种识别中断源的技术或方式。识别中断源的目的是找到中断源对应的中断服务程序的入口地址的地址，即获得向量地址。

### 3.程序中断和调用子程序有何区别？

- 两者的根本区别主要表现在服务时间和服务对象上不一样。
- 调用子程序过程发生的时间是已知的和固定的，即在主程序中的调用指令(CALL)执行时发生主程序调用子程序过程，调用指令所在位置是已知的和固定的。而中断过程发生的时间一般是随机的，CPU 在执行某个主程序时收到中断源提出的中断申请，就发生中断过程，而中断申请一般由硬件电路产生，申请提出时间是随机的。也可以说，调用子程序是程序设计者事先安排的，而执行中断服务程序是由系统工作环境随机决定的
- 子程序完全为主程序服务，两者属于主从关系。主程序需要子程序时就去调用子程序，并把调用结果带回主程序继续执行。而中断服务程序与主程序二者一般是无关的，不存在谁为谁服务的问题，两者是平行关系。
- 主程序调用子程序的过程完全属于软件处理过程，不需要专门的硬件电路；而中断处理系统是一个软/硬件结合的系统，需要专门的硬件电路才能完成中断处理的过程
- 子程序嵌套可实现若干级，嵌套的最多级数受计算机内存开辟的堆栈大小限制；而中断嵌套级数主要由中断优先级来决定，一般优先级数不会很大。
- 从宏观上看，虽然程序中断方式克服了程序査询方式中的 CPU“踏步”现象，实现了 CPU 与 I/O 并行工作，提高了 CPU 的资源利用率，
  但从微观操作分析，CPU 在处理中断服务程序时，仍需暂停原程序的正常运行，尤其是当高速 I/O 设备或辅助存储器频繁地、成批地与主存交换信息时，需要不断打断 CPU 执行现行程序，而执行中断服务程序。

### 4.IO 指令和通道指令有何区别？

- 4.IO 指令和通道指令有何区别？ **I/O 指令是 CPU 指令系统的一部分**，是 CPU 用来控制输入/输出操作的指令，由 CPU 译码后执行。在具有通道结构的机器中，I/O 指令不实现 I/O 数据传送，主要完成启、停 I/O 设备，査询通道和 I/O 设备的状态，及控制通道进行其他一些操作等。 **通道指令是通道本身的指令**，用来执行 I/O 操作，如读、写、磁带走带及磁盘找道等操作。

完结撒花

# 实验

| S3  | S2  | S1  | S0  | M = H<br/>逻辑运算            | M = L<br/>算术运算<br>$\overline{CIN}=H$ | M = L<br/>算术运算<br/>$\overline{CIN} = L$ |
| --- | --- | --- | --- | ----------------------------- | ---------------------------------------- | ------------------------------------------- |
| 0   | 0   | 0   | 0   | $F = \overline{A}$            | $F = A$                                  | $F = A +1$                                  |
| 0   | 0   | 0   | 1   | $F = \overline{(A + B)}$      | $F = A + B$                              | $F = ( A + B ) +1$                          |
| 0   | 0   | 1   | 0   | $F = (\overline{A})B$         | $F = A + \overline{B}$                   | $F = ( A + \overline{B}) +1$                |
| 0   | 0   | 1   | 1   | $F = 0$                       | $F = -1 (2s\ Comp)$                      | $F = 0$                                     |
| 0   | 1   | 0   | 0   | $ F = \overline{(AB) }$       | $F = A +A(\overline{B})$                 | $F = A +A(\overline{B}) +1$                 |
| 0   | 1   | 0   | 1   | $F = \overline{B}$            | $F = ( A + B ) +A(\overline{B})$         | $F = ( A + B ) +A(\overline{B}) +1$         |
| 0   | 1   | 1   | 0   | $F = A \oplus B$              | $F = A -B -1$                            | $F = A -B$                                  |
| 0   | 1   | 1   | 1   | $F = A(\overline{B})$         | $F = A(\overline{B}) -1$                 | $F = A(\overline{B})$                       |
| 1   | 0   | 0   | 0   | $F = \overline{A}+ B$         | $F = A +AB$                              | $F = A +AB +1$                              |
| 1   | 0   | 0   | 1   | $F = \overline{(A \oplus B)}$ | $F = A +B$                               | $F = A +B +1$                               |
| 1   | 0   | 1   | 0   | $F = B$                       | $F = ( A + \overline{B} ) +AB$           | $F = ( A + \overline{B}) +AB +1$            |
| 1   | 0   | 1   | 1   | $F = AB$                      | $F = AB -1$                              | $F = AB$                                    |
| 1   | 1   | 0   | 0   | $F = 1$                       | $F = A +A$                               | $F = A +A +1$                               |
| 1   | 1   | 0   | 1   | $F = A + \overline{B}$        | $F = ( A + B ) +A$                       | $F = ( A + B ) +A +1$                       |
| 1   | 1   | 1   | 0   | $F = A + B$                   | $F = ( A + \overline{B}) +A$             | $F = ( A + \overline{B}) +A +1$             |
| 1   | 1   | 1   | 1   | $F = A$                       | $F = A -1$                               | $F = A$                                     |

- CIN:低位进位
